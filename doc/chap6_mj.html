<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (SimplicialSurfaces) - Chapter 6: Example Applications</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap6"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap6.html">[MathJax off]</a></p>
<p><a id="X7D93D2807ADCAF05" name="X7D93D2807ADCAF05"></a></p>
<div class="ChapSects"><a href="chap6_mj.html#X7D93D2807ADCAF05">6 <span class="Heading">Example Applications</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X7903D18F7F8370D6">6.1 <span class="Heading">Constructing a spherical surface with 30 faces and trivial automorphism group</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X85DB2E3B8646E5FF">6.2 <span class="Heading">Analysing a given surface</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X8046CA867DCD5BD4">6.3 <span class="Heading">Constructing a complicated surface from a simple one</span></a>
</span>
</div>
</div>

<h3>6 <span class="Heading">Example Applications</span></h3>

<p>This chapter contains examples of several advanced applications for the <code class="keyw">SimplicialSurface</code>--package. It mainly serves as a guideline that shows which problems can be solved by the package. If it uses many unclear terms, it is recommended to skip this chapter.</p>

<p><a id="X7903D18F7F8370D6" name="X7903D18F7F8370D6"></a></p>

<h4>6.1 <span class="Heading">Constructing a spherical surface with 30 faces and trivial automorphism group</span></h4>

<p>In this section, we want to construct a simplicial surface with the following properties:</p>

<ol>
<li><p>It is spherical, i.e. closed, orientable, with Euler-characteristic 2.</p>

</li>
<li><p>It has exactly 30 faces.</p>

</li>
<li><p>It has trivial automorphism group.</p>

</li>
</ol>
<p>A simple way to construct large surfaces is by stacking together small surfaces with <code class="keyw">ConnectedFaceSum</code> (<a href="chap12_mj.html#X83F38B1383C923D4"><span class="RefLink">12.5-1</span></a>). Combining two spherical surfaces with 16 faces would create a spherical surface with 30 faces (since two faces are lost in the construction). We can obtain a list of spherical surfaces with 16 faces by accessing the surface-library with <code class="keyw">AllSimplicialSpheres</code> (<a href="chap14_mj.html#X86B313C47C8DC372"><span class="RefLink">14.2-1</span></a>):</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf16 := AllSimplicialSpheres(16);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(surf16);</span>
10
</pre></div>

<p>The method <code class="keyw">ConnectedFaceSum</code> requires flags of the surfaces we want to combine. We can obtain the set of all flags by calling <code class="keyw">Flags</code>(<a href="chap22_mj.html#X82975C097EC3C998"><span class="RefLink">22.1-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Flags(surf16[1]);</span>
[ [ 1, 1, 1 ], [ 1, 1, 2 ], [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 1 ], [ 1, 3, 3 ], 
  [ 1, 4, 2 ], [ 1, 4, 4 ], [ 2, 5, 5 ], [ 2, 5, 6 ], [ 2, 6, 7 ], [ 2, 6, 8 ], 
  [ 2, 7, 5 ], [ 2, 7, 7 ], [ 2, 8, 6 ], [ 2, 8, 8 ], [ 3, 5, 5 ], [ 3, 5, 6 ], 
  [ 3, 9, 5 ], [ 3, 9, 9 ], [ 3, 10, 6 ], [ 3, 10, 10 ], [ 3, 11, 9 ], 
  [ 3, 11, 10 ], [ 4, 6, 7 ], [ 4, 6, 8 ], [ 4, 12, 7 ], [ 4, 12, 11 ], 
  [ 4, 13, 8 ], [ 4, 13, 12 ], [ 4, 14, 11 ], [ 4, 14, 12 ], [ 5, 7, 5 ], 
  [ 5, 7, 7 ], [ 5, 9, 5 ], [ 5, 9, 9 ], [ 5, 12, 7 ], [ 5, 12, 11 ], 
  [ 5, 15, 9 ], [ 5, 15, 13 ], [ 5, 16, 11 ], [ 5, 16, 14 ], [ 5, 17, 13 ], 
  [ 5, 17, 14 ], [ 6, 8, 6 ], [ 6, 8, 8 ], [ 6, 10, 6 ], [ 6, 10, 10 ], 
  [ 6, 13, 8 ], [ 6, 13, 12 ], [ 6, 18, 10 ], [ 6, 18, 15 ], [ 6, 19, 12 ], 
  [ 6, 19, 16 ], [ 6, 20, 15 ], [ 6, 20, 16 ], [ 7, 1, 1 ], [ 7, 1, 2 ], 
  [ 7, 11, 9 ], [ 7, 11, 10 ], [ 7, 15, 9 ], [ 7, 15, 13 ], [ 7, 18, 10 ], 
  [ 7, 18, 15 ], [ 7, 21, 1 ], [ 7, 21, 13 ], [ 7, 22, 2 ], [ 7, 22, 15 ], 
  [ 8, 2, 3 ], [ 8, 2, 4 ], [ 8, 14, 11 ], [ 8, 14, 12 ], [ 8, 16, 11 ], 
  [ 8, 16, 14 ], [ 8, 19, 12 ], [ 8, 19, 16 ], [ 8, 23, 3 ], [ 8, 23, 14 ], 
  [ 8, 24, 4 ], [ 8, 24, 16 ], [ 9, 3, 1 ], [ 9, 3, 3 ], [ 9, 17, 13 ], 
  [ 9, 17, 14 ], [ 9, 21, 1 ], [ 9, 21, 13 ], [ 9, 23, 3 ], [ 9, 23, 14 ], 
  [ 10, 4, 2 ], [ 10, 4, 4 ], [ 10, 20, 15 ], [ 10, 20, 16 ], [ 10, 22, 2 ], 
  [ 10, 22, 15 ], [ 10, 24, 4 ], [ 10, 24, 16 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surfA := surf16[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surfB := surf16[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">newSurf := ConnectedFaceSum(surfA, Flags(surfA)[1], surfB, Flags(surfB)[1]);</span>
simplicial surface (17 vertices, 45 edges, and 30 faces)
</pre></div>

<p>To check whether this new surface has trivial automorphism group, we compute the automorphism group with <code class="keyw">AutomorphismGroup</code> (<a href="chap15_mj.html#X846C2BB57A331B47"><span class="RefLink">15.6-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTrivial(AutomorphismGroup(newSurf));</span>
true
</pre></div>

<p>Since this is the trivial group, we succeeded in our goal.</p>

<p><a id="X85DB2E3B8646E5FF" name="X85DB2E3B8646E5FF"></a></p>

<h4>6.2 <span class="Heading">Analysing a given surface</span></h4>

<p>In this section, we present several options to analyse a given surface. As an example, we will use the surface that we constructed in the last section.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">newSurf;</span>
simplicial surface (17 vertices, 45 edges, and 30 faces)
</pre></div>

<p>We can already read of the number of vertices, edges, and faces. Some other elementary properties are orientability (<code class="keyw">IsOrientablComplex</code>, <a href="chap8_mj.html#X828D14988078FA78"><span class="RefLink">8.7-1</span></a>), connectivity (<code class="keyw">IsConnectedComplex</code>, <a href="chap8_mj.html#X7BCB8E3A80E10882"><span class="RefLink">8.6-1</span></a>), closedness (<code class="keyw">IsClosedComplex</code>, <a href="chap9_mj.html#X8246710587712346"><span class="RefLink">9.1-2</span></a>), and the Euler-characteristic (<code class="keyw">EulerCharacteristic</code>, <a href="chap9_mj.html#X83B1CE797E04CEBD"><span class="RefLink">9.1-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOrientableSurface(newSurf);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConnectedSurface(newSurf);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsClosedSurface(newSurf);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EulerCharacteristic(newSurf);</span>
2
</pre></div>

<p>In our case, we can deduce that the surface <var class="Arg">newSurf</var> can be represented as a triangulation of the sphere. We might want to know how many vertices there are of different degrees. This can be found out by using <code class="keyw">CounterOfVertices</code> (<a href="chap9_mj.html#X7C7444547DB3BAB5"><span class="RefLink">9.2-4</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ListCounter(CounterOfVertices(newSurf));</span>
[ [ 4, 8 ], [ 5, 2 ], [ 6, 5 ], [ 7, 1 ], [ 11, 1 ] ]
</pre></div>

<p>This tells us that there are 8 vertices of degree 4, for example. We could be interested in the distance of the two vertices of degree 5. For that, we have to find these vertices first. For this, we need to know the degrees of each vertex. This can be calculated by <code class="keyw">DegreeOfVertex</code> (<a href="chap9_mj.html#X82E938C180DA3C56"><span class="RefLink">9.2-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Filtered( Vertices(newSurf), v -&gt; DegreeOfVertex(newSurf,v) = 5 );</span>
[ 31, 33 ]
</pre></div>

<p>The distance between two vertices can be calculated with <code class="keyw">DistanceOfVertices</code> (<a href="chap11_mj.html#X7A434B2B7E107E66"><span class="RefLink">11.1-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DistanceOfVertices(newSurf, 31, 33);</span>
1
</pre></div>

<p>Therefore, the two vertices of degree 5 are adjacent.</p>

<p><a id="X8046CA867DCD5BD4" name="X8046CA867DCD5BD4"></a></p>

<h4>6.3 <span class="Heading">Constructing a complicated surface from a simple one</span></h4>

<p>In this section, we want to construct the following surface:</p>

<ol>
<li><p>Start with a spherical surface that has 10 faces, two vertices of degree 5 and five vertices of degree 4, such that the two vertices of degree 5 are not adjacent.</p>

</li>
<li><p>Pick two adjacent faces that are not incident to the same vertex of degree 5 and ``stack'' an octahedron onto them.</p>

</li>
<li><p>Compute the automorphism group of the resulting surface.</p>

</li>
<li><p>Remove the unique vertex that is fixed by the whole automorphism group.</p>

</li>
</ol>
<p>A tedious way would be to construct this surface by hand, label all vertices, edges, and faces, and use one of the methods from chapter <a href="chap4_mj.html#X7C77E62B7FD24306"><span class="RefLink">4</span></a> to construct the surface. Instead, we can also follow the guidelines to construct the surface. First, we have to obtain the spherical surface. Since the two vertices of degree 5 are not adjacent, the faces incident to them are distinct. We can construct those by the method <code class="keyw">SimplicialUmbrella</code> (<a href="chap14_mj.html#X860EF4C583F576EE"><span class="RefLink">14.4-4</span></a>):</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">umb5 := SimplicialUmbrella(5);</span>
simplicial surface (6 vertices, 10 edges, and 5 faces)
</pre></div>

<p>Since two of these umbrellas have 10 faces in total, we can construct the surface from two umbrellas. We can do so by identifying their boundaries. This process is known as <em>joining</em> and the relevant methods are documented in section <a href="chap12_mj.html#X82623EE88772F585"><span class="RefLink">12.4</span></a>. For our purpose, we need <code class="keyw">JoinBoundaries</code> (<a href="chap12_mj.html#X7FAFA27E7CC8A11C"><span class="RefLink">12.4-5</span></a>). This method requires a vertex and an edge of each umbrella, that lie on the boundary and are incident to each other. The easiest way would be to look up the labelling in the documentation of <code class="keyw">SimplicialUmbrella</code> (<a href="chap14_mj.html#X860EF4C583F576EE"><span class="RefLink">14.4-4</span></a>), but we can also find one of them ourselves:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">boundaryEdges := BoundaryEdges(umb5);</span>
[ 6, 7, 8, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">verts := VerticesOfEdge(umb5, 6);</span>
[ 1, 2 ]
</pre></div>

<p>Therefore, 1 is a boundary vertex incident to the boundary edge 6. This allows us to join the boundaries of two umbrellas.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">join := JoinBoundaries(umb5, [1,6], umb5, [1,6]);</span>
[ simplicial surface (7 vertices, 15 edges, and 10 faces), 
    ( v17, E21, v18, E22, v19, E23, v20, E24, v21, E25, v17 )
    , 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">doubleFiveGon := join[1];</span>
simplicial surface (7 vertices, 15 edges, and 10 faces)
</pre></div>

<p>The second component of <var class="Arg">join</var> is a vertex-edge-path (compare section <a href="chap8_mj.html#X7BA338C9785BE58F"><span class="RefLink">8.1</span></a>) that describes how the old boundary lies in the new surface. In particular, <span class="SimpleMath">\(E21\)</span> tells us that edge 21 was a boundary edge before the joining. Therefore, the two faces adjacent to that edge are not incident to the same vertex of degree 5.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">adjFaces := FacesOfEdge(doubleFiveGon, 21);</span>
[1, 11]
</pre></div>

<p>Next, we want to ``stack'' an octahedron onto each of these faces. We can construct an octahedron directly by calling <code class="keyw">Octahedron</code> (<a href="chap14_mj.html#X84BE285087AAC1F7"><span class="RefLink">14.3-4</span></a>), and we can ``stack'' two surfaces by using <code class="keyw">ConnectedFaceSum</code> (<a href="chap12_mj.html#X83F38B1383C923D4"><span class="RefLink">12.5-1</span></a>). Unfortunately, this method requires a flag of each surface (it needs to know how exactly we want to combine the surfaces). Since the octahedron is highly symmetric, all possible choices lead to the same surface. For the flag of <var class="Arg">doubleFiveGon</var> we already have an edge (21) and a face (1 and 11). We only need a vertex incident to the edge.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesOfEdge(doubleFiveGon, 21);</span>
[ 17, 18 ]
</pre></div>

<p>For the octahedron, we can use any flag. We can use <code class="keyw">Flags</code> (<a href="chap22_mj.html#X82975C097EC3C998"><span class="RefLink">22.1-1</span></a>) to compute all of them.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">octa := Octahedron();</span>
simplicial surface (6 vertices, 12 edges, and 8 faces)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">octaFlag := Flags(octa)[1];</span>
[ 1, 1, 1 ]
</pre></div>

<p>This allows the first combination.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">faceSum1 := ConnectedFaceSum(doubleFiveGon, [17,21,1], octa, [1,1,1]);</span>
simplicial surface (10 vertices, 24 edges, and 16 faces)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ 17, 21, 11 ] in Flags(faceSum1);</span>
false
</pre></div>

<p>Such a combination might force a partial relabelling of the surface and in our case, this has happened: the triple <span class="SimpleMath">\([17,21,11]\)</span> is no flag of the new surface. Fortunately, it is easy to reconstruct: We are searching for a face whose vertices have degrees <span class="SimpleMath">\([5,6,6]\)</span>. To localise such subconfigurations, the methods of Section <a href="chap10_mj.html#X78B121DE81968BF8"><span class="RefLink">10.4</span></a> can be used. For our purposes, the method <code class="keyw">FacesWithVertexProperties</code> (<a href="chap10_mj.html#X86AE834A811D5799"><span class="RefLink">10.4-3</span></a>) is appropriate.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">face := FacesWithVertexProperties(faceSum1, [ </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               v -&gt; FaceDegreeOfVertex(faceSum1, v) = 5,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               v -&gt; FaceDegreeOfVertex(faceSum1, v) = 6,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               v -&gt; FaceDegreeOfVertex(faceSum1, v) = 6]);</span>
[ 11 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edge := EdgesOfFace(faceSum1, face[1])[1];</span>
11
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vertex := VerticesOfEdge(faceSum1, edge)[1];</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">faceSum2 := ConnectedFaceSum(faceSum1,[vertex, edge, face[1]], octa,[1,1,1]);</span>
simplicial surface (13 vertices, 33 edges, and 22 faces)
</pre></div>

<p>To compute the automorphism group, we can use the methods from Section <a href="chap15_mj.html#X8489C4E47B92C882"><span class="RefLink">15.6</span></a> . Since we want to compute all fixed vertices, we use <code class="keyw">AutomorphismGroupOnVertices</code> (<a href="chap15_mj.html#X85C02FE87E3E2FE4"><span class="RefLink">15.6-3</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut := AutomorphismGroupOnVertices(faceSum2);</span>
permutation group with 2 generators
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fixedVertices := Filtered( Vertices(faceSum2), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   v -&gt; ForAll(aut, a -&gt; v^a=v) );</span>
[ 20 ]
</pre></div>

<p>Removing the vertex <span class="SimpleMath">\(20\)</span> means removing all faces incident to that vertex. This can be done by <code class="keyw">SubsurfaceByFaces</code> (<a href="chap12_mj.html#X80D57580835A52AE"><span class="RefLink">12.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">incFaces := FacesOfVertex(faceSum2, fixedVertices[1]);</span>
[ 3, 4, 13, 14 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">remainingFaces := Difference( Faces(faceSum2), incFaces );</span>
[ 2, 5, 12, 15, 27, 28, 29, 30, 31, 32, 33, 42, 43, 44, 45, 46, 47, 48 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := SubsurfaceByFaces(faceSum2, remainingFaces);</span>
simplicial surface (12 vertices, 29 edges, and 18 faces)
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chap23_mj.html">23</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
