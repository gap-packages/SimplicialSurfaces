<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (SimplicialSurfaces) - Chapter 4: Constructing surfaces by their incidence structure</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap4"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap4_mj.html">[MathJax on]</a></p>
<p><a id="X7C77E62B7FD24306" name="X7C77E62B7FD24306"></a></p>
<div class="ChapSects"><a href="chap4.html#X7C77E62B7FD24306">4 <span class="Heading">Constructing surfaces by their incidence structure</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X84E0B8C47E00294C">4.1 <span class="Heading">DownwardIncidence</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X86072A31828988AC">4.1-1 PolygonalComplexByDownwardIncidence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7FFBAFD68536C448">4.1-2 PolygonalSurfaceByDownwardIncidence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8499F8DA7F50BCE4">4.1-3 TriangularComplexByDownwardIncidence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X87868FA37F718C86">4.1-4 SimplicialSurfaceByDownwardIncidence</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X81576B0884A43DE7">4.2 <span class="Heading">UpwardIncidence</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X79EB4BD7876291C8">4.2-1 PolygonalComplexByUpwardIncidence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X823576D780DDDD2C">4.2-2 PolygonalSurfaceByUpwardIncidence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8174B3817FD3842F">4.2-3 TriangularComplexByUpwardIncidence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E76D2C17FF2B44D">4.2-4 SimplicialSurfaceByUpwardIncidence</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X7E78E04585A36A71">4.3 <span class="Heading">VerticesInFaces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X78E09695826CD6ED">4.3-1 PolygonalComplexByVerticesInFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E4BFA4385D39A09">4.3-2 PolygonalSurfaceByVerticesInFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X85D36E0B876D61E6">4.3-3 TriangularComplexByVerticesInFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X84055BAE874C5184">4.3-4 SimplicialSurfaceByVerticesInFaces</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X877FCE0683FE4660">4.4 <span class="Heading">Umbrella Descriptors</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7C3B252E83E2A73D">4.4-1 UmbrellaDescriptorOfSurface</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7A48C67185BD801E">4.4-2 UmbrellaTipDescriptorOfSurface</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7F53E2328613B49D">4.4-3 SimplicialSurfaceByUmbrellaDescriptor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7A218DC979F4DC6A">4.4-4 NormedUmbrellaDescriptor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X79A359EB78D6EA66">4.4-5 DegreeSequenceOfUmbrellaDescriptor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X86575D907E1EC579">4.4-6 AllUmbrellaDescriptorsOfDegreeSequence</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X7F1D30C67983EE96">4.5 <span class="Heading">Constructing surfaces via their Dress Group</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7933327C787B3C7B">4.5-1 SimplicialSurfaceByDressGroup</a></span>
</div></div>
</div>

<h3>4 <span class="Heading">Constructing surfaces by their incidence structure</span></h3>

<p>In chapter <a href="chap2.html#X86693EE97EA70D6D"><span class="RefLink">2</span></a> we introduced polygonal complexes (as a generalization of simplicial surfaces). They are based on incidence structures, which were analysed in chapter <a href="chap3.html#X864ADF3D7B40CE9B"><span class="RefLink">3</span></a>.</p>

<p>This chapter deals with the construction of custom polygonal complexes and simplicial surfaces. This package offers three different ways to construct a polygonal complex "from scratch":</p>


<ul>
<li><p>Choose from a few standard example (like platonic solids). This is covered in the later sections of chapter <a href="chap14.html#X8544AE207F51DAA5"><span class="RefLink">14</span></a>.</p>

</li>
<li><p>Define it directly by its incidence structure (this will be the main content of this chapter).</p>

</li>
<li><p>Use the surface database to find appropriate complexes. This will be handled in the first section of chapter <a href="chap14.html#X8544AE207F51DAA5"><span class="RefLink">14</span></a>.</p>

</li>
</ul>
<p>For simplicial surfaces another and more convenient constructor is the constructor</p>


<ul>
<li><p><code class="keyw">SimplicialSurfaceByUmbrellaDescriptor</code>( <var class="Arg">edgeFacePaths</var> ).</p>

</li>
</ul>
<p>All other constructures which work for general polygonal complexes are structured like [Type]By[Method](args), e.g.</p>


<ul>
<li><p><code class="keyw">PolygonalComplexByDownwardIncidence</code>( <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</p>

</li>
</ul>
<p>They are mainly distinguished by the different attributes they need to construct the incidence structures:</p>


<ul>
<li><p><em>DownwardIncidence</em> (<a href="chap4.html#X84E0B8C47E00294C"><span class="RefLink">4.1</span></a>): <code class="keyw">VerticesOfEdges</code> (<a href="chap3.html#X86B1B478802C8EFA"><span class="RefLink">3.2-3</span></a>), <code class="keyw">EdgesOfFaces</code> (<a href="chap3.html#X7928464E7DB7BC68"><span class="RefLink">3.2-6</span></a>)</p>

</li>
<li><p><em>UpwardIncidence</em> (<a href="chap4.html#X81576B0884A43DE7"><span class="RefLink">4.2</span></a>): <code class="keyw">EdgesOfVertices</code> (<a href="chap3.html#X7C1E97627C3BA4E8"><span class="RefLink">3.2-1</span></a>), <code class="keyw">FacesOfEdges</code> (<a href="chap3.html#X862071AD7F5FF297"><span class="RefLink">3.2-4</span></a>)</p>

</li>
<li><p><em>VerticesInFaces</em> (<a href="chap4.html#X7E78E04585A36A71"><span class="RefLink">4.3</span></a>): <code class="keyw">VerticesOfFaces</code> (<a href="chap3.html#X78D892FB7C330942"><span class="RefLink">3.2-5</span></a>)</p>

</li>
</ul>
<p><a id="X84E0B8C47E00294C" name="X84E0B8C47E00294C"></a></p>

<h4>4.1 <span class="Heading">DownwardIncidence</span></h4>

<p>The <em>DownwardIncidence</em>-constructors are based on the attributes <code class="keyw">VerticesOfEdges</code> (<a href="chap3.html#X86B1B478802C8EFA"><span class="RefLink">3.2-3</span></a>) and <code class="keyw">EdgesOfFaces</code> (<a href="chap3.html#X7928464E7DB7BC68"><span class="RefLink">3.2-6</span></a>). From these any polygonal structure from chapter <a href="chap2.html#X86693EE97EA70D6D"><span class="RefLink">2</span></a> can be build.</p>

<p>To use the constructor, we need to describe two incidence relations:</p>


<ul>
<li><p>incidence between vertices and edges (the argument <var class="Arg">verticesOfEdges</var>)</p>

</li>
<li><p>incidence between edges and faces (the argument <var class="Arg">edgesOfFaces</var>)</p>

</li>
</ul>
<p>As an example, consider the following polygonal surface: <br><img src='./images/_Wrapper_constructors-1-1.svg'> </img> <br></p>

<p>Both of the incidence relations described above are given as lists. The list <var class="Arg">verticesOfEdges</var> contains an entry for each edge of the polygonal surface. This entry contains the set of all vertices that are incident to that edge.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">verticesOfEdges := </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         [,[3,5],,,,[3,7],,[3,11],,[7,11],,[5,13],,[7,13],[11,13]];</span>
[ , [ 3, 5 ],,,, [ 3, 7 ],, [ 3, 11 ],, [ 7, 11 ],, [ 5, 13 ],, 
  [ 7, 13 ], [ 11, 13 ] ]
</pre></div>

<p>Similarly the list <var class="Arg">edgesOfFaces</var> has an entry for each face with the set of incident edges.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edgesOfFaces := [ [2,6,12,14], , , [6,8,10], , , , , [10,14,15] ];</span>
[ [ 2, 6, 12, 14 ],,, [ 6, 8, 10 ],,,,, [ 10, 14, 15 ] ]
</pre></div>

<p>With these two lists we can construct the desired polygonal surface.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolygonalSurfaceByDownwardIncidence( verticesOfEdges, edgesOfFaces );;</span>
</pre></div>

<p>The <em>DownwardIncidence</em>-constructors also allow the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var>. If those sets are given, the incidence information is checked for compatibility with them, that is (1) the integers in <var class="Arg">faces</var> correspond to the bound positions of <var class="Arg">edgesOfFaces</var>, (2) the integers in <var class="Arg">edges</var> are those occurring in the entries of <var class="Arg">edgesOfFaces</var> and also correspond to the bound entries of <var class="Arg">verticesOfEdges</var> and (3) the integers in <var class="Arg">verties</var> are those occurring in the entries of <var class="Arg">verticesOfEdges</var>. This is not strictly necessary since this information can be deduced from the lists <var class="Arg">verticesOfEdges</var> and <var class="Arg">edgesOfFaces</var>.</p>

<p>In practice it is common to make mistakes in manually giving these lists. Especially in such situations it is recommended to use the optional arguments as they might catch some mistakes.</p>

<p>To make giving these lists easier, each of these sets can be replaces by a positive integer <var class="Arg">n</var>, which will be interpreted as the set <span class="SimpleMath">[1,...,n]</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolygonalSurfaceByDownwardIncidence( [3,5,7,11,13], [2,6,8,10,12,14,15], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [1,4,9], verticesOfEdges, edgesOfFaces );;</span>
</pre></div>

<p>The name <em>DownwardIncidence</em> stems from the fact that the incidence relation is given by referring to structures of lower dimension - an edge (dimension 1) is defined by two vertices (dimension 0) and a face (dimension 2) is defined by edges.</p>

<p><a id="X86072A31828988AC" name="X86072A31828988AC"></a></p>

<h5>4.1-1 PolygonalComplexByDownwardIncidence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByDownwardIncidence</code>( <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByDownwardIncidence</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByDownwardIncidenceNC</code>( <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByDownwardIncidenceNC</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal complex</p>

<p>This method constructs a polygonal complex (<a href="chap2.html#X82D7D2228628B979"><span class="RefLink">2.1</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">VerticesOfEdges</code> (<a href="chap3.html#X86B1B478802C8EFA"><span class="RefLink">3.2-3</span></a>) and <code class="keyw">EdgesOfFaces</code> (<a href="chap3.html#X7928464E7DB7BC68"><span class="RefLink">3.2-6</span></a>) and takes these arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">verticesOfEdges</code>: A list that has an entry for each edge (a positive integer). This entry has to be a list of the two vertices (as positive integers) of this edge.</p>

</li>
<li><p><code class="keyw">edgesOfFaces</code>: A list that has an entry for each face (a positive integer). This entry has to be a list of the edges (as positive integers) of this face.</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Are <var class="Arg">verticesOfEdges</var> and <var class="Arg">edgesOfFaces</var> lists where the entries are lists of positive integers?</p>

</li>
<li><p>Is every bound entry of <var class="Arg">verticesOfEdges</var> a list with exactly two entries that are different?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">edgesOfFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is <code class="keyw">Union</code>(<var class="Arg">verticesOfEdges</var>) = <var class="Arg">vertices</var>?</p>

</li>
<li><p>Are the bound positions of <var class="Arg">verticesOfEdges</var> equal to <code class="keyw">Union</code>(<var class="Arg">edgesOfFaces</var>)? If <var class="Arg">edges</var> is given, is it equal to those two sets?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to the bound positions of <var class="Arg">edgesOfFaces</var>?</p>

</li>
</ul>
<p>As an example consider the following net of a polygonal complex (note, there are both vertex and edge ramifications): <br><img src='./images/_Wrapper_constructors-2-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">complex := PolygonalComplexByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,2],[2,3],[1,3],[3,6],[1,6],[6,5],[2,5],[1,5]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,7,8],[1,7,8],[2,4,6,7],[2,4,6,7],[3,4,5],[3,4,5]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RamifiedVertices(complex);</span>
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChaoticVertices(complex);</span>
[ 2, 3, 5, 6 ]
</pre></div>

<p><a id="X7FFBAFD68536C448" name="X7FFBAFD68536C448"></a></p>

<h5>4.1-2 PolygonalSurfaceByDownwardIncidence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByDownwardIncidence</code>( <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByDownwardIncidence</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByDownwardIncidenceNC</code>( <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByDownwardIncidenceNC</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal surface</p>

<p>This method constructs a polygonal surface (<a href="chap2.html#X78FF094A8196A963"><span class="RefLink">2.3</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">VerticesOfEdges</code> (<a href="chap3.html#X86B1B478802C8EFA"><span class="RefLink">3.2-3</span></a>) and <code class="keyw">EdgesOfFaces</code> (<a href="chap3.html#X7928464E7DB7BC68"><span class="RefLink">3.2-6</span></a>) and takes these arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">verticesOfEdges</code>: A list that has an entry for each edge (a positive integer). This entry has to be a list of the two vertices (as positive integers) of this edge.</p>

</li>
<li><p><code class="keyw">edgesOfFaces</code>: A list that has an entry for each face (a positive integer). This entry has to be a list of the edges (as positive integers) of this face.</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Are <var class="Arg">verticesOfEdges</var> and <var class="Arg">edgesOfFaces</var> lists where the entries are lists of positive integers?</p>

</li>
<li><p>Is every bound entry of <var class="Arg">verticesOfEdges</var> a list with exactly two entries that are different?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">edgesOfFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is <code class="keyw">Union</code>(<var class="Arg">verticesOfEdges</var>) = <var class="Arg">vertices</var>?</p>

</li>
<li><p>Are the bound positions of <var class="Arg">verticesOfEdges</var> equal to <code class="keyw">Union</code>(<var class="Arg">edgesOfFaces</var>)? If <var class="Arg">edges</var> is given, is it equal to those two sets?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to the bound positions of <var class="Arg">edgesOfFaces</var>?</p>

</li>
</ul>
<p>As an example consider the following net of a simplicial surface: <br><img src='./images/_Wrapper_constructors-3-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := PolygonalSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,2],[2,3],[3,4],[4,5],[5,1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [1,6],[2,7],[2,8],[3,9],[3,10],[4,11],[4,12],[5,13],[5,14],[1,15],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [6,15],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,13],[13,14],[14,15]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[6,15,16],[1,6,7,17],[7,8,18],[2,8,9,19],[9,10,20],[3,10,11,21],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [11,12,22],[4,12,13,23],[13,14,24],[5,14,15,25]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsClosedSurface(surf);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PerimeterOfHoles(surf);</span>
[ (v1, E1, v2, E2, v3, E3, v4, E4, v5, E5, v1), 
  (v6, E16, v15, E25, v14, E24, v13, E23, v12, E22, v11, E21, 
            v10, E20, v9, E19, v8, E18, v7, E17, v6) ]
</pre></div>

<p><a id="X8499F8DA7F50BCE4" name="X8499F8DA7F50BCE4"></a></p>

<h5>4.1-3 TriangularComplexByDownwardIncidence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByDownwardIncidence</code>( <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByDownwardIncidence</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByDownwardIncidenceNC</code>( <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByDownwardIncidenceNC</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a triangular complex</p>

<p>This method constructs a triangular complex (<a href="chap2.html#X82D7D2228628B979"><span class="RefLink">2.1</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">VerticesOfEdges</code> (<a href="chap3.html#X86B1B478802C8EFA"><span class="RefLink">3.2-3</span></a>) and <code class="keyw">EdgesOfFaces</code> (<a href="chap3.html#X7928464E7DB7BC68"><span class="RefLink">3.2-6</span></a>) and takes these arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">verticesOfEdges</code>: A list that has an entry for each edge (a positive integer). This entry has to be a list of the two vertices (as positive integers) of this edge.</p>

</li>
<li><p><code class="keyw">edgesOfFaces</code>: A list that has an entry for each face (a positive integer). This entry has to be a list of the edges (as positive integers) of this face.</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Are <var class="Arg">verticesOfEdges</var> and <var class="Arg">edgesOfFaces</var> lists where the entries are lists of positive integers?</p>

</li>
<li><p>Is every bound entry of <var class="Arg">verticesOfEdges</var> a list with exactly two entries that are different?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">edgesOfFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is <code class="keyw">Union</code>(<var class="Arg">verticesOfEdges</var>) = <var class="Arg">vertices</var>?</p>

</li>
<li><p>Are the bound positions of <var class="Arg">verticesOfEdges</var> equal to <code class="keyw">Union</code>(<var class="Arg">edgesOfFaces</var>)? If <var class="Arg">edges</var> is given, is it equal to those two sets?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to the bound positions of <var class="Arg">edgesOfFaces</var>?</p>

</li>
</ul>
<p>As an example consider the following net of a triangular complex (at the vertices and edges marked red, there are ramifications): <br><img src='./images/_Wrapper_constructors-4-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">complex := TriangularComplexByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,7],[2,7],[3,7],[4,7],[5,7],[6,7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [1,9],[8,9],[3,9],[4,9],[9,10],[6,9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [1,12],[11,12],[3,12],[4,12],[12,13],[6,12],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [1,2],[2,3],[3,4],[4,5],[5,6],,[1,8],[3,8],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [4,10],[6,10],[1,11],[3,11],[4,13],[6,13]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,2,19],[2,3,20],[3,4,21],[4,5,22],[5,6,23],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [7,8,25],[8,9,26],[9,10,21],[10,11,27],[11,12,28],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [13,14,29],[14,15,30],[15,16,21],[16,17,31],[17,18,32]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UmbrellaPathPartitionOfVertex(complex, 1);</span>
[ | e1, F1, e19 |, | e7, F6, e25 |, | e13, F11, e29 | ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UmbrellaPathPartitionOfVertex(complex, 6);</span>
[ | e6, F5, e23 |, | e12, F10, e28 |, | e18, F15, e32 | ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FacesOfEdge(complex, 21);</span>
[ 3, 8, 13 ]
</pre></div>

<p><a id="X87868FA37F718C86" name="X87868FA37F718C86"></a></p>

<h5>4.1-4 SimplicialSurfaceByDownwardIncidence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByDownwardIncidence</code>( <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByDownwardIncidence</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByDownwardIncidenceNC</code>( <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByDownwardIncidenceNC</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">verticesOfEdges</var>, <var class="Arg">edgesOfFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a simplicial surface</p>

<p>This method constructs a simplicial surface (<a href="chap2.html#X78FF094A8196A963"><span class="RefLink">2.3</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">VerticesOfEdges</code> (<a href="chap3.html#X86B1B478802C8EFA"><span class="RefLink">3.2-3</span></a>) and <code class="keyw">EdgesOfFaces</code> (<a href="chap3.html#X7928464E7DB7BC68"><span class="RefLink">3.2-6</span></a>) and takes these arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">verticesOfEdges</code>: A list that has an entry for each edge (a positive integer). This entry has to be a list of the two vertices (as positive integers) of this edge.</p>

</li>
<li><p><code class="keyw">edgesOfFaces</code>: A list that has an entry for each face (a positive integer). This entry has to be a list of the edges (as positive integers) of this face.</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Are <var class="Arg">verticesOfEdges</var> and <var class="Arg">edgesOfFaces</var> lists where the entries are lists of positive integers?</p>

</li>
<li><p>Is every bound entry of <var class="Arg">verticesOfEdges</var> a list with exactly two entries that are different?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">edgesOfFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is <code class="keyw">Union</code>(<var class="Arg">verticesOfEdges</var>) = <var class="Arg">vertices</var>?</p>

</li>
<li><p>Are the bound positions of <var class="Arg">verticesOfEdges</var> equal to <code class="keyw">Union</code>(<var class="Arg">edgesOfFaces</var>)? If <var class="Arg">edges</var> is given, is it equal to those two sets?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to the bound positions of <var class="Arg">edgesOfFaces</var>?</p>

</li>
</ul>
<p>As an example consider the following net of a simplicial surface: <br><img src='./images/_Wrapper_constructors-5-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,5],[2,5],[5,6],[5,9],[4,5],,[1,4],[1,2],[2,6],,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [1,7],[2,7],[6,7],[7,10],[4,7],,[6,9],[4,9],[6,10],[4,10],,[9,10]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,5,7],[1,2,8],[2,3,9],[3,4,17],[4,5,18],,,,[17,19,22],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [18,20,22],[7,11,15],[8,11,12],[9,12,13],[13,14,19],[14,15,20]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Vertices(surf);</span>
[ 1, 2, 4, 5, 6, 7, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Edges(surf);</span>
[ 1, 2, 3, 4, 5, 7, 8, 9, 11, 12, 13, 14, 15, 17, 18, 19, 20, 22 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Faces(surf);</span>
[ 1, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14, 15 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EulerCharacteristic(surf);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsClosedSurface(surf);</span>
true
</pre></div>

<p><a id="X81576B0884A43DE7" name="X81576B0884A43DE7"></a></p>

<h4>4.2 <span class="Heading">UpwardIncidence</span></h4>

<p>The <em>UpwardIncidence</em>-constructors are based on the attributes <code class="keyw">EdgesOfVertices</code> (<a href="chap3.html#X7C1E97627C3BA4E8"><span class="RefLink">3.2-1</span></a>) and <code class="keyw">FacesOfEdges</code> (<a href="chap3.html#X862071AD7F5FF297"><span class="RefLink">3.2-4</span></a>). From these any polygonal structure from chapter <a href="chap2.html#X86693EE97EA70D6D"><span class="RefLink">2</span></a> can be build.</p>

<p>To use the constructor, we need to describe two incidence relations:</p>


<ul>
<li><p>incidence between edges and vertices (the argument <var class="Arg">edgesOfVertices</var>)</p>

</li>
<li><p>incidence between faces and edges (the argument <var class="Arg">facesOfEdges</var>)</p>

</li>
</ul>
<p>As an example, consider the following polygonal surface: <br><img src='./images/_Wrapper_constructors-6-1.svg'> </img> <br></p>

<p>Both of the incidence relations described above are given as lists. The list <var class="Arg">edgesOfVertices</var> contains an entry for each vertex of the polygonal surface. This entry contains the set of all edges that are incident to that vertex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edgesOfVertices := </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [,, [2,6,8],, [2,12],, [6,10,14],,,, [8,10,15],, [12,14,15] ];</span>
[ ,,  [ 2, 6, 8 ],, [ 2, 12 ],, [ 6, 10, 14 ],,,, [ 8, 10, 15 ],, 
    [ 12, 14, 15 ] ]
</pre></div>

<p>Similarly the list <var class="Arg">facesOfEdges</var> has an entry for each edge with the set of incident faces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">facesOfEdges := [ , [1], , , , [1,4], , [4], , [4,9], , [1], , [1,9], [9] ];</span>
[ , [ 1 ],,,, [ 1, 4 ],, [ 4 ],, [ 4, 9 ],, [ 1 ],, [ 1, 9 ], [ 9 ] ]
</pre></div>

<p>With these two lists we can construct the desired polygonal surface.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolygonalSurfaceByUpwardIncidence( edgesOfVertices, facesOfEdges );;</span>
</pre></div>

<p>The <em>UpwardIncidence</em>-constructors also allow the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var>. If those sets are given, the incidence information is checked for compatibility with them. This is not strictly necessary since this information can be deduced from the lists <var class="Arg">edgesOfVertices</var> and <var class="Arg">facesOfEdges</var>.</p>

<p>In practice it is common to make mistakes in manually giving these lists. Especially in such situations it is recommended to use the optional arguments as they might catch some mistakes.</p>

<p>To make giving these lists easier, each of these sets can be replaces by a positive integer <var class="Arg">n</var>, which will be interpreted as the set <span class="SimpleMath">[1,...,n]</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolygonalSurfaceByUpwardIncidence( [3,5,7,11,13], [2,6,8,10,12,14,15], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [1,4,9], edgesOfVertices, facesOfEdges );;</span>
</pre></div>

<p>The name <em>UpwardIncidence</em> stems from the fact that the incidence relation is given by referring to structures of higher dimension - a vertex (dimension 0) is defined by its edges (dimension 1) and an edge is defined by faces (dimension 2).</p>

<p><a id="X79EB4BD7876291C8" name="X79EB4BD7876291C8"></a></p>

<h5>4.2-1 PolygonalComplexByUpwardIncidence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByUpwardIncidence</code>( <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByUpwardIncidence</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByUpwardIncidenceNC</code>( <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByUpwardIncidenceNC</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal complex</p>

<p>This method constructs a polygonal complex (<a href="chap2.html#X82D7D2228628B979"><span class="RefLink">2.1</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">EdgesOfVertices</code> (<a href="chap3.html#X7C1E97627C3BA4E8"><span class="RefLink">3.2-1</span></a>) and <code class="keyw">FacesOfEdges</code> (<a href="chap3.html#X862071AD7F5FF297"><span class="RefLink">3.2-4</span></a>) and takes these arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">edgesOfVertices</code>: A list that has an entry for each vertex (a positive integer). This entry has to be a list of the incident edges (as positive integers) of this vertex.</p>

</li>
<li><p><code class="keyw">facesOfEdges</code>: A list that has an entry for each edge (a positive integer). This entry has to be a list of the incident faces (as positive integers) of this edge.</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Are <var class="Arg">edgesOfVertices</var> and <var class="Arg">facesOfEdges</var> lists where the entries are lists of positive integers?</p>

</li>
<li><p>Does every edge of the resulting polygonal complex has exactly two incident vertices?</p>

</li>
<li><p>Does every face of the resulting polygonal complex has at least two incident edges?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">edgesOfFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is it equal to the bound positions of <var class="Arg">edgesOfVertices</var>?</p>

</li>
<li><p>Are the bound positions of <var class="Arg">facesOfEdges</var> equal to <code class="keyw">Union</code>(<var class="Arg">edgesOfVertices</var>)? If <var class="Arg">edges</var> is given, is it equal to those two sets?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to <code class="keyw">Union</code>(<var class="Arg">facesOfEdges</var>)?</p>

</li>
</ul>
<p>As an example consider the following net of a polygonal complex (note, there are both vertex and edge ramifications): <br><img src='./images/_Wrapper_constructors-7-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">complex := PolygonalComplexByUpwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,8,3,5],[1,2,7],[2,3,4],,[6,7,8],[4,5,6]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,2],[3,4],[5,6],[3,4,5,6],[5,6],[3,4],[1,2,3,4],[1,2]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RamifiedVertices(complex);</span>
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChaoticVertices(complex);</span>
[ 2, 3, 5, 6 ]
</pre></div>

<p><a id="X823576D780DDDD2C" name="X823576D780DDDD2C"></a></p>

<h5>4.2-2 PolygonalSurfaceByUpwardIncidence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByUpwardIncidence</code>( <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByUpwardIncidence</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByUpwardIncidenceNC</code>( <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByUpwardIncidenceNC</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal surface</p>

<p>This method constructs a polygonal surface (<a href="chap2.html#X78FF094A8196A963"><span class="RefLink">2.3</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">EdgesOfVertices</code> (<a href="chap3.html#X7C1E97627C3BA4E8"><span class="RefLink">3.2-1</span></a>) and <code class="keyw">FacesOfEdges</code> (<a href="chap3.html#X862071AD7F5FF297"><span class="RefLink">3.2-4</span></a>) and takes these arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">edgesOfVertices</code>: A list that has an entry for each vertex (a positive integer). This entry has to be a list of the incident edges (as positive integers) of this vertex.</p>

</li>
<li><p><code class="keyw">facesOfEdges</code>: A list that has an entry for each edge (a positive integer). This entry has to be a list of the incident faces (as positive integers) of this edge.</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Are <var class="Arg">edgesOfVertices</var> and <var class="Arg">facesOfEdges</var> lists where the entries are lists of positive integers?</p>

</li>
<li><p>Does every edge of the resulting polygonal complex has exactly two incident vertices?</p>

</li>
<li><p>Does every face of the resulting polygonal complex has at least two incident edges?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">edgesOfFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is it equal to the bound positions of <var class="Arg">edgesOfVertices</var>?</p>

</li>
<li><p>Are the bound positions of <var class="Arg">facesOfEdges</var> equal to <code class="keyw">Union</code>(<var class="Arg">edgesOfVertices</var>)? If <var class="Arg">edges</var> is given, is it equal to those two sets?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to <code class="keyw">Union</code>(<var class="Arg">facesOfEdges</var>)?</p>

</li>
</ul>
<p>As an example consider the following net of a simplicial surface: <br><img src='./images/_Wrapper_constructors-8-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := PolygonalSurfaceByUpwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,5,6,15],[1,2,7,8],[2,3,9,10],[3,4,11,12],[4,5,13,14],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [6,16,17],[7,17,18],[8,18,19],[9,19,20],[10,20,21],[11,21,22],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [12,22,23],[13,23,24],[14,24,25],[15,16,25]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[2],[4],[6],[8],[10],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [8,9],[9,10],[1,10],[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsClosedSurface(surf);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PerimeterOfHoles(surf);</span>
[ (v1, E1, v2, E2, v3, E3, v4, E4, v5, E5, v1), 
  (v6, E16, v15, E25, v14, E24, v13, E23, v12, E22, v11, E21, 
            v10, E20, v9, E19, v8, E18, v7, E17, v6) ]
</pre></div>

<p><a id="X8174B3817FD3842F" name="X8174B3817FD3842F"></a></p>

<h5>4.2-3 TriangularComplexByUpwardIncidence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByUpwardIncidence</code>( <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByUpwardIncidence</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByUpwardIncidenceNC</code>( <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByUpwardIncidenceNC</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a triangular complex</p>

<p>This method constructs a triangular complex (<a href="chap2.html#X82D7D2228628B979"><span class="RefLink">2.1</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">EdgesOfVertices</code> (<a href="chap3.html#X7C1E97627C3BA4E8"><span class="RefLink">3.2-1</span></a>) and <code class="keyw">FacesOfEdges</code> (<a href="chap3.html#X862071AD7F5FF297"><span class="RefLink">3.2-4</span></a>) and takes these arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">edgesOfVertices</code>: A list that has an entry for each vertex (a positive integer). This entry has to be a list of the incident edges (as positive integers) of this vertex.</p>

</li>
<li><p><code class="keyw">facesOfEdges</code>: A list that has an entry for each edge (a positive integer). This entry has to be a list of the incident faces (as positive integers) of this edge.</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Are <var class="Arg">edgesOfVertices</var> and <var class="Arg">facesOfEdges</var> lists where the entries are lists of positive integers?</p>

</li>
<li><p>Does every edge of the resulting polygonal complex has exactly two incident vertices?</p>

</li>
<li><p>Does every face of the resulting polygonal complex has at least two incident edges?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">edgesOfFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is it equal to the bound positions of <var class="Arg">edgesOfVertices</var>?</p>

</li>
<li><p>Are the bound positions of <var class="Arg">facesOfEdges</var> equal to <code class="keyw">Union</code>(<var class="Arg">edgesOfVertices</var>)? If <var class="Arg">edges</var> is given, is it equal to those two sets?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to <code class="keyw">Union</code>(<var class="Arg">facesOfEdges</var>)?</p>

</li>
</ul>
<p>As an example consider the following net of a triangular complex (at the vertices and edges marked red, there are ramifications): <br><img src='./images/_Wrapper_constructors-9-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">complex := TriangularComplexByUpwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,19,7,25,13,29],[2,19,20],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [20,3,21,9,26,15,30],[22,4,21,10,27,16,31],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [23,5,22],[6,23,12,28,18,32],[1,2,3,4,5,6],[26,8,25],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [7,8,9,10,11,12],[27,11,28],[30,14,29],[13,14,15,16,17,18],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [31,17,32]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1],[1,2],[2,3],[3,4],[4,5],[5],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [6],[6,7],[7,8],[8,9],[9,10],[10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [11],[11,12],[12,13],[13,14],[14,15],[15],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [1],[2],[3,8,13],[4],[5],,[6],[7],[9],[10],[11],[12],[14],[15]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UmbrellaPathPartitionOfVertex(complex, 1);</span>
[ | e1, F1, e19 |, | e7, F6, e25 |, | e13, F11, e29 | ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UmbrellaPathPartitionOfVertex(complex, 6);</span>
[ | e6, F5, e23 |, | e12, F10, e28 |, | e18, F15, e32 | ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FacesOfEdge(complex, 21);</span>
[ 3, 8, 13 ]
</pre></div>

<p><a id="X7E76D2C17FF2B44D" name="X7E76D2C17FF2B44D"></a></p>

<h5>4.2-4 SimplicialSurfaceByUpwardIncidence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByUpwardIncidence</code>( <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByUpwardIncidence</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByUpwardIncidenceNC</code>( <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByUpwardIncidenceNC</code>( <var class="Arg">vertices</var>, <var class="Arg">edges</var>, <var class="Arg">faces</var>, <var class="Arg">edgesOfVertices</var>, <var class="Arg">facesOfEdges</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a simplicial surface</p>

<p>This method constructs a simplicial surface (<a href="chap2.html#X78FF094A8196A963"><span class="RefLink">2.3</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">EdgesOfVertices</code> (<a href="chap3.html#X7C1E97627C3BA4E8"><span class="RefLink">3.2-1</span></a>) and <code class="keyw">FacesOfEdges</code> (<a href="chap3.html#X862071AD7F5FF297"><span class="RefLink">3.2-4</span></a>) and takes these arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">edgesOfVertices</code>: A list that has an entry for each vertex (a positive integer). This entry has to be a list of the incident edges (as positive integers) of this vertex.</p>

</li>
<li><p><code class="keyw">facesOfEdges</code>: A list that has an entry for each edge (a positive integer). This entry has to be a list of the incident faces (as positive integers) of this edge.</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Are <var class="Arg">edgesOfVertices</var> and <var class="Arg">facesOfEdges</var> lists where the entries are lists of positive integers?</p>

</li>
<li><p>Does every edge of the resulting polygonal complex has exactly two incident vertices?</p>

</li>
<li><p>Does every face of the resulting polygonal complex has at least two incident edges?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">edgesOfFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is it equal to the bound positions of <var class="Arg">edgesOfVertices</var>?</p>

</li>
<li><p>Are the bound positions of <var class="Arg">facesOfEdges</var> equal to <code class="keyw">Union</code>(<var class="Arg">edgesOfVertices</var>)? If <var class="Arg">edges</var> is given, is it equal to those two sets?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to <code class="keyw">Union</code>(<var class="Arg">facesOfEdges</var>)?</p>

</li>
</ul>
<p>As an example consider the following net of a simplicial surface: <br><img src='./images/_Wrapper_constructors-10-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := SimplicialSurfaceByUpwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,7,8,11],[2,8,9,12],,[5,7,15,18,20],[1,2,3,4,5],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [3,9,13,17,19],[11,12,13,14,15],,[4,17,18,22],[14,19,20,22]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,2],[2,3],[3,4],[4,5],[1,5],,[1,11],[2,12],[3,13],,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [11,12],[12,13],[13,14],[14,15],[11,15],,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [4,9],[5,10],[9,14],[10,15],,[9,10]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Vertices(surf);</span>
[ 1, 2, 4, 5, 6, 7, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Edges(surf);</span>
[ 1, 2, 3, 4, 5, 7, 8, 9, 11, 12, 13, 14, 15, 17, 18, 19, 20, 22 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Faces(surf);</span>
[ 1, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14, 15 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EulerCharacteristic(surf);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsClosedSurface(surf);</span>
true
</pre></div>

<p><a id="X7E78E04585A36A71" name="X7E78E04585A36A71"></a></p>

<h4>4.3 <span class="Heading">VerticesInFaces</span></h4>

<p>The <em>VerticesInFaces</em>-constructors are based on the attribute <code class="keyw">VerticesOfFaces</code> (<a href="chap3.html#X78D892FB7C330942"><span class="RefLink">3.2-5</span></a>) for triangular faces and an oriented version of it for non-triangular ones.</p>

<p>To use the constructor we need to know the incidence relation between vertices and faces (the edge information has to be deduced from that). Therefore it is assumed that every edge is uniquely identified by its incident vertices. Apart from this restriction, every polygonal structure from chapter <a href="chap2.html#X86693EE97EA70D6D"><span class="RefLink">2</span></a> can be build.</p>

<p>Consider the following polygonal surface: <br><img src='./images/_Wrapper_constructors-11-1.svg'> </img> <br></p>

<p>The face with number <span class="SimpleMath">4</span> is incident to the vertices <span class="SimpleMath">[3,7,11]</span>. Since the edges of a triangle are uniquely determined by its vertices, the constructor will assume that the edges <span class="SimpleMath">[3,7]</span>, <span class="SimpleMath">[3,11]</span> and <span class="SimpleMath">[7,11]</span> exist.</p>

<p>The face <span class="SimpleMath">9</span> with the incident vertices <span class="SimpleMath">[7,11,13]</span> is handled in the same way. This triangle also contains an edge with vertices <span class="SimpleMath">7</span> and <span class="SimpleMath">11</span>, which is assumed to be the same edge <span class="SimpleMath">[7,11]</span> of the face <span class="SimpleMath">4</span>.</p>

<p>This deduction of edges does not work if a face is incident to more than three vertices. Here the face with number <span class="SimpleMath">1</span> is incident to four different vertices: <span class="SimpleMath">[3,5,7,13]</span>. As it is not obvious which of these are connected by edges, the method needs additional information. If the vertices are given as the list <span class="SimpleMath">[3,5,13,7]</span>, the edges can be defined by adjacent entries in this list (the first and last entry count as adjacent).</p>

<p>The full rules for the edge deduction are:</p>


<ul>
<li><p>An edge is uniquely identified by its incident vertices.</p>

</li>
<li><p>If a face is given by the vertex list <span class="SimpleMath">[v_1, v_2, ..., v_k]</span> then adjacent vertices in the list are assumed to form an edge of the face (first and last vertex count as adjacent). In this case we would have the edges <span class="SimpleMath">[v_1,v_2]</span>, <span class="SimpleMath">[v_2,v_3]</span>, ..., <span class="SimpleMath">[v_k,v_1]</span>.</p>

</li>
</ul>
<p>The incidence information is given as a list that has an entry for each face. For every face this entry is a list of the incident vertices, where the order of the vertices in the list determines the edges (if there are more than three vertices).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">verticesInFaces := [ [3,5,13,7], , , [3,11,7], , , , , [7,11,13] ];</span>
[ [ 3, 5, 13, 7 ],,, [ 3, 11, 7 ],,,,, [ 7, 11, 13 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolygonalSurfaceByVerticesInFaces( verticesInFaces );;</span>
</pre></div>

<p>The <em>VerticesInFaces</em>-constructors also allow the optional arguments <var class="Arg">vertices</var> and <var class="Arg">faces</var>. If those sets are given, the incidence information is checked for compatibility with them. This is very useful in practice to notice typos in the incidence relations. As this can be deduced from the argument <var class="Arg">verticesInFaces</var> it is not necessary to give these optional arguments.</p>

<p>In practice it is common to make mistakes in manually typing this list. Especially in a situation like this it is recommended to use the optional arguments to catch some mistakes.</p>

<p>To make this easier, each of these optional arguments can be replaced by a positive integer <var class="Arg">n</var> (which will be interpreted as the set <span class="SimpleMath">[1,...,n]</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolygonalSurfaceByVerticesInFaces( [3,5,7,11,13], [1,4,9], verticesInFaces );;</span>
</pre></div>

<p><a id="X78E09695826CD6ED" name="X78E09695826CD6ED"></a></p>

<h5>4.3-1 PolygonalComplexByVerticesInFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByVerticesInFaces</code>( <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByVerticesInFaces</code>( <var class="Arg">vertices</var>, <var class="Arg">faces</var>, <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByVerticesInFacesNC</code>( <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalComplexByVerticesInFacesNC</code>( <var class="Arg">vertices</var>, <var class="Arg">faces</var>, <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal complex</p>

<p>This method constructs a polygonal complex (<a href="chap2.html#X82D7D2228628B979"><span class="RefLink">2.1</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">VerticesOfFaces</code> (<a href="chap3.html#X78D892FB7C330942"><span class="RefLink">3.2-5</span></a>) and requires that the edges be uniquely defined by their incident vertices. It takes the following arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">verticesInFaces</code>: A list that has an entry for each positive integer corresponding to a face. This entry is a list of positive integers <span class="SimpleMath">[v_1, v_2 , ..., v_k ]</span>, each corresponding to a vertex incident to the face. Moreover, two consecutive vertices in this list are the vertices of an edge incident to the face (here the first and last vertex count as consecutive).</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Is <var class="Arg">verticesInFaces</var> a list whose entries are lists of pairwise different positive integers?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">verticesInFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is <code class="keyw">Union</code>(<var class="Arg">verticesInFaces</var>) = <var class="Arg">vertices</var>?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to the bound positions of <var class="Arg">verticesInFaces</var>?</p>

</li>
</ul>
<p>As an example consider the following net of a polygonal complex (note, there are both vertex and edge ramifications): <br><img src='./images/_Wrapper_constructors-12-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">complex := PolygonalComplexByVerticesInFaces(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,2,5],[1,2,5],[2,3,6,5],[2,3,6,5],[1,6,3],[1,3,6]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RamifiedVertices(complex);</span>
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChaoticVertices(complex);</span>
[ 2, 3, 5, 6 ]
</pre></div>

<p><a id="X7E4BFA4385D39A09" name="X7E4BFA4385D39A09"></a></p>

<h5>4.3-2 PolygonalSurfaceByVerticesInFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByVerticesInFaces</code>( <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByVerticesInFaces</code>( <var class="Arg">vertices</var>, <var class="Arg">faces</var>, <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByVerticesInFacesNC</code>( <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalSurfaceByVerticesInFacesNC</code>( <var class="Arg">vertices</var>, <var class="Arg">faces</var>, <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal surface</p>

<p>This method constructs a polygonal surface (<a href="chap2.html#X78FF094A8196A963"><span class="RefLink">2.3</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">VerticesOfFaces</code> (<a href="chap3.html#X78D892FB7C330942"><span class="RefLink">3.2-5</span></a>) and requires that the edges be uniquely defined by their incident vertices. It takes the following arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">verticesInFaces</code>: A list that has an entry for each positive integer corresponding to a face. This entry is a list of positive integers <span class="SimpleMath">[v_1, v_2 , ..., v_k ]</span>, each corresponding to a vertex incident to the face. Moreover, two consecutive vertices in this list are the vertices of an edge incident to the face (here the first and last vertex count as consecutive).</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Is <var class="Arg">verticesInFaces</var> a list whose entries are lists of pairwise different positive integers?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">verticesInFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is <code class="keyw">Union</code>(<var class="Arg">verticesInFaces</var>) = <var class="Arg">vertices</var>?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to the bound positions of <var class="Arg">verticesInFaces</var>?</p>

</li>
</ul>
<p>As an example consider the following net of a simplicial surface: <br><img src='./images/_Wrapper_constructors-13-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := PolygonalSurfaceByVerticesInFaces(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,6,15],[1,2,7,6],[2,7,8],[2,3,9,8],[3,9,10],[3,4,11,10],[4,11,12],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [4,5,13,12],[5,13,14],[1,5,14,15]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsClosedSurface(surf);</span>
false
</pre></div>

<p><a id="X85D36E0B876D61E6" name="X85D36E0B876D61E6"></a></p>

<h5>4.3-3 TriangularComplexByVerticesInFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByVerticesInFaces</code>( <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByVerticesInFaces</code>( <var class="Arg">vertices</var>, <var class="Arg">faces</var>, <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByVerticesInFacesNC</code>( <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TriangularComplexByVerticesInFacesNC</code>( <var class="Arg">vertices</var>, <var class="Arg">faces</var>, <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a triangular complex</p>

<p>This method constructs a triangular complex (<a href="chap2.html#X82D7D2228628B979"><span class="RefLink">2.1</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">VerticesOfFaces</code> (<a href="chap3.html#X78D892FB7C330942"><span class="RefLink">3.2-5</span></a>) and requires that the edges be uniquely defined by their incident vertices. It takes the following arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">verticesInFaces</code>: A list that has an entry for each positive integer corresponding to a face. This entry is a list of positive integers <span class="SimpleMath">[v_1, v_2 , ..., v_k ]</span>, each corresponding to a vertex incident to the face. Moreover, two consecutive vertices in this list are the vertices of an edge incident to the face (here the first and last vertex count as consecutive).</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Is <var class="Arg">verticesInFaces</var> a list whose entries are lists of pairwise different positive integers?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">verticesInFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is <code class="keyw">Union</code>(<var class="Arg">verticesInFaces</var>) = <var class="Arg">vertices</var>?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to the bound positions of <var class="Arg">verticesInFaces</var>?</p>

</li>
</ul>
<p>As an example consider the following net of a triangular complex (at the vertices and edges marked red, there are ramifications): <br><img src='./images/_Wrapper_constructors-14-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">complex := TriangularComplexByVerticesInFaces(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,2,7],[2,3,7],[3,4,7],[4,5,7],[5,6,7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [1,8,9],[3,8,9],[3,4,9],[4,10,9],[6,10,9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [1,11,12],[3,11,12],[3,4,12],[4,13,12],[6,13,12]]);;</span>
</pre></div>

<p><a id="X84055BAE874C5184" name="X84055BAE874C5184"></a></p>

<h5>4.3-4 SimplicialSurfaceByVerticesInFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByVerticesInFaces</code>( <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByVerticesInFaces</code>( <var class="Arg">vertices</var>, <var class="Arg">faces</var>, <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByVerticesInFacesNC</code>( <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByVerticesInFacesNC</code>( <var class="Arg">vertices</var>, <var class="Arg">faces</var>, <var class="Arg">verticesInFaces</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a simplicial surface</p>

<p>This method constructs a simplicial surface (<a href="chap2.html#X78FF094A8196A963"><span class="RefLink">2.3</span></a>) where vertices, edges and faces are represented by positive integers. It is based on the attributes <code class="keyw">VerticesOfFaces</code> (<a href="chap3.html#X78D892FB7C330942"><span class="RefLink">3.2-5</span></a>) and requires that the edges be uniquely defined by their incident vertices. It takes the following arguments:</p>

<ol>
<li><p>OPTIONAL: Each of the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> is either a set of positive integers or a positive integer. In the latter case, an integer <span class="SimpleMath">n</span> represents the set <span class="SimpleMath">[1,...,n]</span>.</p>

<p>Although these arguments can be deduced from the non-optional arguments, their use is recommended to catch mistakes in these other arguments.</p>

</li>
<li><p><code class="keyw">verticesInFaces</code>: A list that has an entry for each positive integer corresponding to a face. This entry is a list of positive integers <span class="SimpleMath">[v_1, v_2 , ..., v_k ]</span>, each corresponding to a vertex incident to the face. Moreover, two consecutive vertices in this list are the vertices of an edge incident to the face (here the first and last vertex count as consecutive).</p>

</li>
</ol>
<p>The method checks whether the answer to each of the following questions is true. None of these checks will be performed by the NC-version.</p>


<ul>
<li><p>Are the optional arguments <var class="Arg">vertices</var>, <var class="Arg">edges</var> and <var class="Arg">faces</var> either positive integers or sets of positive integers?</p>

</li>
<li><p>Is <var class="Arg">verticesInFaces</var> a list whose entries are lists of pairwise different positive integers?</p>

</li>
<li><p>Does every bound entry of <var class="Arg">verticesInFaces</var> contain at least two elements?</p>

</li>
<li><p>If <var class="Arg">vertices</var> is given, is <code class="keyw">Union</code>(<var class="Arg">verticesInFaces</var>) = <var class="Arg">vertices</var>?</p>

</li>
<li><p>If <var class="Arg">faces</var> is given, is it equal to the bound positions of <var class="Arg">verticesInFaces</var>?</p>

</li>
</ul>
<p>As an example consider the following net of a simplicial surface: <br><img src='./images/_Wrapper_constructors-15-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := SimplicialSurfaceByVerticesInFaces(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,4,5],[1,2,5],[2,5,6],[5,6,9],[4,5,9],,,,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [6,9,10],[4,9,10],[1,4,7],[1,2,7],[2,6,7],[6,7,10],[4,7,10]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Vertices(surf);</span>
[ 1, 2, 4, 5, 6, 7, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfEdges(surf);</span>
18
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Faces(surf);</span>
[ 1, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14, 15 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EulerCharacteristic(surf);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsClosedSurface(surf);</span>
true
</pre></div>

<p><a id="X877FCE0683FE4660" name="X877FCE0683FE4660"></a></p>

<h4>4.4 <span class="Heading">Umbrella Descriptors</span></h4>

<p>A very useful way of describing surfaces is by listing the umbrella paths around each vertex. Formally, an umbrella descriptor of a simplicial surface is a list <var class="Arg">umbdesc</var>, describing a simplicial surface. The bound entries in <var class="Arg">umbdesc</var> are cyclic permutations or lists of integers. The set of faces of the surface is the set of points which either are moved by a cyclic permutation or occur in a list in <var class="Arg">umbdesc</var>. The edges of the surface correspond to pairs of faces <span class="SimpleMath">(i,j)</span>, where either some cycle in <var class="Arg">umbdesc</var> maps <span class="SimpleMath">i</span> to <span class="SimpleMath">j</span> or <span class="SimpleMath">i</span> and <span class="SimpleMath">j</span> occur as neighbours in a list. The vertices of the surface are the positive integers corresponding to the bound positions of <var class="Arg">umbdesc</var>. If position <span class="SimpleMath">i</span> of <var class="Arg">umbdesc</var> is bound, then the <span class="SimpleMath">i</span>-th entry represents the vertex with name <span class="SimpleMath">i</span>. If the vertex named <span class="SimpleMath">i</span> is inner, then the <span class="SimpleMath">i</span>-th entry in <var class="Arg">umbdesc</var> is a cyclic permutation of the faces in the umbrella path around the vertex, mapping a face to an adjacent face. The order of the permutation is equal to the degree of the vertex. If the vertex named <span class="SimpleMath">i</span> is a boundary vertex, then the <span class="SimpleMath">i</span>-th entry in <var class="Arg">umbdesc</var> is a list consisting of the faces in the umbrella path of the vertex such that adjacent faces are consecutive and the two faces with boundary edges are the first and the last entry of the list. The length of the list is equal to the degree of the vertex.</p>

<p><a id="X7C3B252E83E2A73D" name="X7C3B252E83E2A73D"></a></p>

<h5>4.4-1 UmbrellaDescriptorOfSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UmbrellaDescriptorOfSurface</code>( <var class="Arg">surface</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Let <var class="Arg">surf</var> be a simplicial surface. This method returns an umbrella descriptor of <var class="Arg">surf</var>, where an umbrella descriptor of a simplicial surface is a list <var class="Arg">umbdesc</var>, describing a simplicial surface. The bound entries in <var class="Arg">umbdesc</var> are cyclic permutations or lists of integers. The set of faces of the surface is the set of points which either are moved by a cyclic permutation or occur in a list in <var class="Arg">umbdesc</var>. The edges of the surface correspond to pairs of faces <span class="SimpleMath">(i,j)</span>, where either some cycle in <var class="Arg">umbdesc</var> maps <span class="SimpleMath">i</span> to <span class="SimpleMath">j</span> or <span class="SimpleMath">i</span> and <span class="SimpleMath">j</span> occur as neighbours in a list. The vertices of the surface are the positive integers corresponding to the bound positions of <var class="Arg">umbdesc</var>. If position <span class="SimpleMath">i</span> of <var class="Arg">umbdesc</var> is bound, then the <span class="SimpleMath">i</span>-th entry represents the vertex with name <span class="SimpleMath">i</span>. If the vertex named <span class="SimpleMath">i</span> is inner, then the <span class="SimpleMath">i</span>-th entry in <var class="Arg">umbdesc</var> is a cyclic permutation of the faces in the umbrella path around the vertex, mapping a face to an adjacent face. The order of the permutation is equal to the degree of the vertex. If the vertex named <span class="SimpleMath">i</span> is a boundary vertex, then the <span class="SimpleMath">i</span>-th entry in <var class="Arg">umbdesc</var> is a list consisting of the faces in the umbrella path of the vertex such that adjacent faces are consecutive and the two faces with boundary edges are the first and the last entry of the list. The length of the list is equal to the degree of the vertex.</p>

<p>As an example consider the following net of a simplicial surface. Note that the surface has boundary edges. Moreover, the vertices 1,2,3, and 4 are inner vertices, while 5,6,7,8,9, and 10 are not. Accordingly, the umbrella descriptor of the surface will consist of cyclic permutations for the vertices 1,2,3, and 4 and of lists for the remaining vertices. <br><img src='./images/_Wrapper_constructors-16-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := SimplicialSurfaceByVerticesInFaces( [ [ 1, 2, 5 ], [ 1, 3, 5 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 1, 3, 6 ], [ 1, 4, 6 ], [ 1, 4, 7 ], [ 1, 2, 7 ], [ 2, 7, 8 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 2, 5, 8 ], [ 3, 5, 9 ], [ 3, 6, 9 ], [ 4, 6, 10 ], [ 4, 7, 10 ] ]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UmbrellaDescriptorOfSurface(surf);</span>
[ (1,2,3,4,5,6), (1,8,7,6), (2,9,10,3), (4,11,12,5), [ 8, 1, 2, 9 ],
 [ 10, 3, 4, 11 ], [ 7, 6, 5, 12 ], [ 8, 7 ], [ 9, 10 ], [ 11, 12 ] ]
</pre></div>

<p><a id="X7A48C67185BD801E" name="X7A48C67185BD801E"></a></p>

<h5>4.4-2 UmbrellaTipDescriptorOfSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UmbrellaTipDescriptorOfSurface</code>( <var class="Arg">surface</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Let <var class="Arg">surf</var> be a vertex faithful simplicial surface. This method returns an umbrella tip descriptor of <var class="Arg">surf</var>, where an umbrella tip descriptor of a simplicial surface is a list <var class="Arg">umbtipdesc</var>, describing a simplicial surface. The bound entries in <var class="Arg">umbtipdesc</var> are cyclic permutations or lists of integers. The set of vertices of the surface is the set of points which either are moved by a cyclic permutation or occur in a list in <var class="Arg">umbtipdesc</var>. The edges of the surface correspond to pairs of vertices <span class="SimpleMath">(i,j)</span>, where <span class="SimpleMath">i</span> is the bound position of a cycle or list in <var class="Arg">umbtipdesc</var> and <span class="SimpleMath">j</span> is a vertex that is moved by that cycle or in that list with position <span class="SimpleMath">i</span> in <var class="Arg">umbtipdesc</var>. The faces correspond to tuples of vertices <span class="SimpleMath">(i,j,k)</span>, where <span class="SimpleMath">i</span> is the bound position in <var class="Arg">umbtipdesc</var> of a cycle or list and either that cycle maps <span class="SimpleMath">j</span> to <span class="SimpleMath">k</span> or <span class="SimpleMath">j</span> and <span class="SimpleMath">k</span> occur in that list as neighbours. The vertices of the surface can also be described as the positive integers corresponding to the bound positions of <var class="Arg">umbtipdesc</var>. If position <span class="SimpleMath">i</span> of <var class="Arg">umbtipdesc</var> is bound, then the <span class="SimpleMath">i</span>-th entry represents the vertex with name <span class="SimpleMath">i</span>. An umbrella tip path of a vertex is the umbrella path of a vertex, but instead of an edge-face path, one obtains the outer vertices of that edge path. If the vertex named <span class="SimpleMath">i</span> is inner, then the <span class="SimpleMath">i</span>-th entry in <var class="Arg">umbtipdesc</var> is a cyclic permutation of the vertices in the umbrella tip path around the vertex, mapping a vertex to an adjacent vertex. The order of the permutation is equal to the vertex- and edge-degree of the vertex. If the vertex named <span class="SimpleMath">i</span> is a boundary vertex, then the <span class="SimpleMath">i</span>-th entry in <var class="Arg">umbtipdesc</var> is a list consisting of the vertices in the umbrella tip path of the vertex such that adjacent vertices are consecutive and the two vertices with boundary edges are the first and the last entry of the list. The length of the list is equal to the vertex- and edge-degree of the vertex.</p>

<p>As an example consider the following net of a simplicial surface. Note that the surface has boundary edges. Moreover, the vertices 1,2,3, and 4 are inner vertices, while 5,6,7,8,9, and 10 are not. Accordingly, the umbrella tip descriptor of the surface will consist of cyclic permutations for the vertices 1,2,3, and 4 and of lists for the remaining vertices. <br><img src='./images/_Wrapper_constructors-17-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := SimplicialSurfaceByVerticesInFaces( [ [ 1, 2, 5 ], [ 1, 3, 5 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 1, 3, 6 ], [ 1, 4, 6 ], [ 1, 4, 7 ], [ 1, 2, 7 ], [ 2, 7, 8 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 2, 5, 8 ], [ 3, 5, 9 ], [ 3, 6, 9 ], [ 4, 6, 10 ], [ 4, 7, 10 ] ]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UmbrellaTipDescriptorOfSurface(surf);</span>
[ (2,5,3,6,4,7), (1,5,8,7), (1,5,9,6), (1,6,10,7), [ 8, 2, 1, 3, 9 ], 
 [ 9, 3, 1, 4, 10 ], [ 8, 2, 1, 4, 10 ], [ 5, 2, 7 ], [ 5, 3, 6 ], 
 [ 6, 4, 7 ] ]
</pre></div>

<p><a id="X7F53E2328613B49D" name="X7F53E2328613B49D"></a></p>

<h5>4.4-3 SimplicialSurfaceByUmbrellaDescriptor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByUmbrellaDescriptor</code>( <var class="Arg">surface</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a simplicial surface</p>

<p>This method takes as input a list <var class="Arg">umbdesc</var>, which is an umbrella descriptor of a simplicial surface, see (<a href="chap4.html#X877FCE0683FE4660"><span class="RefLink">4.4</span></a>). If the list <var class="Arg">umbdesc</var> is the umbrella descriptor of a surface <var class="Arg">surf</var>, the method returns <var class="Arg">surf</var>. Otherwise it returns <var class="Arg">false</var>.</p>

<p>As an example consider the following net of a simplicial surface. Note that the surface has boundary edges. Moreover, the vertices 1,2,3, and 4 are inner vertices, while 5,6,7,8,9, and 10 are not. Accordingly, the umbrella descriptor of the surface will consist of cyclic permutations for the vertices 1,2,3, and 4 and of lists for the remaining vertices, namely the umbrella descriptor is: [ (1,2,3,4,5,6), (1,8,7,6), (2,9,10,3), (4,11,12,5), [8,1,2,9], [10,3,4,11], [7,6,5,12], [8,7], [9,10], [11,12] ]. <br><img src='./images/_Wrapper_constructors-18-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := SimplicialSurfaceByUmbrellaDescriptor( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ (1,2,3,4,5,6), (1,8,7,6), (2,9,10,3), (4,11,12,5), [ 8, 1, 2, 9 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [ 10, 3, 4, 11 ], [ 7, 6, 5, 12 ], [ 8, 7 ], [ 9, 10 ], [ 11, 12 ] ]);</span>
simplicial surface (10 vertices, 21 edges, and 12 faces)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfFaces(surf);</span>
12
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> Vertices(surf);</span>
[ 1 .. 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NumberOfEdges(surf);</span>
21
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Faces(surf);</span>
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EulerCharacteristic(surf);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsClosedSurface(surf);</span>
false
</pre></div>

<p><a id="X7A218DC979F4DC6A" name="X7A218DC979F4DC6A"></a></p>

<h5>4.4-4 NormedUmbrellaDescriptor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormedUmbrellaDescriptor</code>( <var class="Arg">umbrelladescriptor</var>, <var class="Arg">face</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormedUmbrellaDescriptor</code>( <var class="Arg">umbrelladescriptor</var>, <var class="Arg">face</var>, <var class="Arg">neighbours</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>A normed umbrella descriptor is a special umbrella descriptor of a surface, where an umbrella descriptor is described in (<a href="chap4.html#X877FCE0683FE4660"><span class="RefLink">4.4</span></a>). The normed umbrella descriptor of a given umbrella descriptor <var class="Arg">umdesc</var> for the face <var class="Arg">face</var> and an optional list of neighbours <var class="Arg">neighbours</var> of <var class="Arg">face</var> is an umbrella descriptor <var class="Arg">normedumdesc</var> for an isomorphic surface. This new surface is obtained from the original surface described by <var class="Arg">umdesc</var> by a renumbering <var class="Arg">f</var> of the faces, where <var class="Arg">f</var> is a bijection from the faces of the original surface to [1,..,<span class="SimpleMath">n</span>], where <span class="SimpleMath">n</span> is the number of faces. This renumbering is initialised follows: <var class="Arg">f(face) = 1</var>. The neighbours of <var class="Arg">face</var> are assigned the numbers 2, 3, ... If the optional argument <var class="Arg">neighbours</var> is present, it must be a subset of the neighbours of <var class="Arg">face</var> and <var class="Arg">f(neighbours[i]) = i+1</var> and <var class="Arg">f(F)=infty</var> for all other faces <var class="Arg">F</var>. Next the umbrellas of the original surface are sorted lexicographically, that is umbrella <var class="Arg">u</var> is less than umbrella <var class="Arg">v</var> if the image <var class="Arg">f(u)</var> is lexicographically less that <var class="Arg">f(v)</var> as dihedral sequences. Each step takes the lexicographically least umbrella <var class="Arg">u</var> still containing a face <var class="Arg">F</var> for which <var class="Arg">f(F)=infty</var> and renumbers each such face in the umbrella consecutively in the order in which they occur in <var class="Arg">u</var> with numbers in [1,..,<span class="SimpleMath">n</span>] not yet used, that is <var class="Arg">f(F)=j</var> for some <var class="Arg">j</var> in [1,..,<span class="SimpleMath">n</span>].</p>

<p>Consider the surface on 10 faces consisting of exactly two inner vertices of degree 5 and having vertex counter <span class="Math">v_2^6v_3^2v_5^2.</span> Its umbrella descriptor is given in the example below. We initialise renumbering of the faces such that <var class="Arg">f(3)=1</var> and the neighbours of 3, namely 2, 4, and 11 such that <var class="Arg">f(2)=2</var>, <var class="Arg">f(4)=3</var> and <var class="Arg">f(11)=4,</var> and <var class="Arg">f(F) = infty</var> for the faces <var class="Arg">F</var> in [1,5,6,7,8,10]. The lexicographically least umbrella is the umbrella containing the faces with new numbers 1, 2, and 3. This is the umbrella <var class="Arg">u=(2,3,4,10,6,8)=(3,4,10,6,8,2)</var> as <var class="Arg">f(u) = (1,2,infty,infty,infty,3)</var>. We rename the three face numbers 10, 6, 8 mapped to infty with the smallest consecutive numbers in [1..10] not yet used. Thus we set <var class="Arg">f(10)=5</var>, <var class="Arg">f(6)=6</var>, <var class="Arg">f(8)=7</var>, that is we rename faces 8, 6 and 10 in this umbrella to 5, 6, and 7. The lexicographically least umbrella whose image under <var class="Arg">f</var> contains infty is <var class="Arg">v = (1,5,2,3,11,7) = (3,2,5,1,7,11)</var> as <var class="Arg">f(v) = (1,2,infty,infty,infty,4)</var>. Thus we renumber the faces 5, 1, and 7 to 8, 9, 10. This defines <var class="Arg">f</var> on all faces and yields the normed umbrella descriptor:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> ud := [ (1,5,2,3,11,7), (2,3,4,10,6,8),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 4, 3, 11 ], [ 5, 2, 8 ], [ 1, 5 ], [ 1, 7 ], [ 7, 11 ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ 4, 10 ], [ 6, 10 ], [ 6, 8 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> nud := NormedUmbrellaDescriptor( ud, 3, [2,4,11]);</span>
[ [ 3, 1, 4 ], (1,2,5,6,7,3), (1,2,8,9,10,4), [ 3, 7 ], [ 4, 10 ], 
 [ 5, 2, 8 ], [ 5, 6 ], [ 6, 7 ], [ 8, 9 ], [ 9, 10 ] ]
</pre></div>

<p>The original surface is depicted on the left, the surface of the normed umbrella descriptor is depicted on the right. <br><img src='./images/_Wrapper_constructors-19-1.svg'> </img> <br></p>

<p>As an example consider the following umbrella descriptor of a simplicial surface on 18 faces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ud1 := [ (4,21,20,25), (5,7,8,6), (5,9,10,6), (7,11,12,8), (5,9,13,14,11,7), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">(6,10,15,16,12,8), (9,13,17,21,20,15,10), (4,25,16,12,11,14,18),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">(13,17,18,14), (15,16,25,20), (4,21,17,18) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf1 := SimplicialSurfaceByUmbrellaDescriptor(ud1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ud2 := NormedUmbrellaDescriptor(ud1, 7, [11, 8, 5]);</span>
[ (1,2,5,3), (1,2,6,7,8,4), (1,3,9,4), (2,5,10,11,12,13,6), (3,5,10,14,15,9),
  (4,8,15,9), (6,7,16,13), (7,8,15,14,17,18,16), 
  (10,11,17,14), (11,12,18,17), (12,13,16,18) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> surf2 := SimplicialSurfaceByUmbrellaDescriptor(ud2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphic(surf1,surf2);</span>
true
</pre></div>

<p>Note that this function can also be applied to umbrella descriptors of surfaces which are not closed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ud1 := [ (1,2,3,4,5), (1,8,7,6,5), (1,8,19,20,9,2), (2,9,10,11,3), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> (3,11,12,13,4), (4,13,14,15,6,5), (6,15,16,17,7), (7,17,18,19,8),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ 10, 9, 20 ], [ 10, 11, 12 ], [ 12, 13, 14 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ 14, 15, 16 ], [ 16, 17, 18 ], [ 18, 19, 20 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf1 := SimplicialSurfaceByUmbrellaDescriptor(ud1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ud2 := NormedUmbrellaDescriptor(ud1, 1, [2, 5, 8]);</span>
[ (1,2,5,6,3), (1,2,7,8,9,4), (1,3,10,11,4), (2,5,12,13,7), (3,6,14,15,16,10),
  (4,9,17,18,11),   (5,6,14,19,12), [ 8, 7, 13 ], [ 8, 9, 17 ], (10,11,18,20,16),
  [ 13, 12, 19 ],    [ 15, 14, 19 ], [ 15, 16, 20 ], [ 17, 18, 20 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> surf2 := SimplicialSurfaceByUmbrellaDescriptor(ud2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphic(surf1,surf2);</span>
true
</pre></div>

<p><a id="X79A359EB78D6EA66" name="X79A359EB78D6EA66"></a></p>

<h5>4.4-5 DegreeSequenceOfUmbrellaDescriptor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DegreeSequenceOfUmbrellaDescriptor</code>( <var class="Arg">umbdesc</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Suppose that <var class="Arg">umdesc</var> is a valid umbrella descriptor of a surface <span class="SimpleMath">S</span>, see (<a href="chap4.html#X877FCE0683FE4660"><span class="RefLink">4.4</span></a>). The degree sequence of <var class="Arg">umdesc</var> is a list <em>degseq</em>. If the <span class="SimpleMath">i</span>-th entry of <var class="Arg">umdesc</var> is bound, then this entry corresponds to a vertex of <span class="SimpleMath">S</span> and the <span class="SimpleMath">i</span>-th entry of <var class="Arg">degseq</var> is a list <span class="SimpleMath">[d,b]</span>, where <span class="SimpleMath">d</span> is the degree of the <span class="SimpleMath">i</span>-th vertex, and the boolean <span class="SimpleMath">b</span> is true, if the <span class="SimpleMath">i</span>-th vertex is inner and false else.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vf := [ [ 1, 3, 4 ], [ 1, 2, 4 ], [ 2, 4, 5 ], [ 2, 5, 6 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ 1, 2, 6 ], [ 1, 6, 7 ], [ 1, 7, 8 ], [ 1, 3, 8 ], [ 3, 4, 9 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ 4, 9, 10 ], [ 4, 5, 10 ], [ 5, 10, 11 ], [ 5, 6, 11 ], [ 6, 11, 12 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ 6, 7, 12 ], [ 7, 12, 13 ], [ 7, 8, 13 ], [ 8, 13, 14 ], [ 3, 8, 14 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ 3, 9, 14 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := SimplicialSurfaceByVerticesInFaces(vf);</span>
simplicial surface (14 vertices, 33 edges, and 20 faces)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ud := UmbrellaDescriptorOfSurface(surf);</span>
[ (1,8,7,6,5,2), (2,3,4,5), (1,9,20,19,8), (1,9,10,11,3,2), (3,11,12,13,4), 
  (4,13,14,15,6,5), (6,15,16,17,7), (7,17,18,19,8), [ 10, 9, 20 ], 
  [ 10, 11, 12 ], [ 12, 13, 14 ], [ 14, 15, 16 ], [ 16, 17, 18 ], 
  [ 20, 19, 18 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DegreeSequenceOfUmbrellaDescriptor(ud);</span>
[ [ 6, true ], [ 4, true ], [ 5, true ], [ 6, true ], [ 5, true ], 
  [ 6, true ], [ 5, true ], [ 5, true ], [ 3, false ], [ 3, false ], 
  [ 3, false ], [ 3, false ], [ 3, false ], [ 3, false ] ]
</pre></div>

<p><a id="X86575D907E1EC579" name="X86575D907E1EC579"></a></p>

<h5>4.4-6 AllUmbrellaDescriptorsOfDegreeSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllUmbrellaDescriptorsOfDegreeSequence</code>( <var class="Arg">degreeseq</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Given a DegreeSequence of a normed UmbrellaDescriptor for a closed simplicial surface which has no vertices of degree 2, this function returns the umbrella descriptors of all simplicial surfaces which have a normed umbrella descriptor matching this degree sequence.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ud :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ (1,6,16,5), (1,6,15,4), (2,21,22,3), (9,11,12,10), (11,17,18,12), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> (7,9,10,8), (7,13,14,8), (1,4,2,3,5), (17,23,21,22,24,18), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> (3,22,24,20,16,5), (2,21,23,19,15,4), (6,16,20,14,13,19,15), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> (7,13,19,23,17,11,9), (8,14,20,24,18,12,10) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf := SimplicialSurfaceByUmbrellaDescriptor( ud );</span>
simplicial surface (14 vertices, 36 edges, and 24 faces)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nud := NormedUmbrellaDescriptor(ud, 1 );</span>
[ (1,2,5,6,3), (1,2,7,4), (1,3,8,4), (2,5,9,10,11,7), (3,6,12,13,14,8), 
  (4,7,11,15,16,14,8), (5,6,12,9), (9,10,17,18,13,12), 
  (10,11,15,19,20,21,17), (13,14,16,22,23,24,18), (15,16,22,19), 
  (17,18,24,21), (19,20,23,22), (20,21,24,23) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ds := DegreeSequenceOfUmbrellaDescriptor(nud);</span>
[ [ 5, true ], [ 4, true ], [ 4, true ], [ 6, true ], [ 6, true ], 
  [ 7, true ], [ 4, true ], [ 6, true ], [ 7, true ], [ 7, true ], 
  [ 4, true ], [ 4, true ], [ 4, true ], [ 4, true ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AllUmbrellaDescriptorsOfDegreeSequence( ds );</span>
[ [ (1,2,5,6,3), (1,2,7,4), (1,3,8,4), (2,5,9,10,11,7), (3,6,12,13,14,8), 
      (4,7,11,15,16,14,8), (5,6,12,9), (9,10,17,18,13,12), 
      (10,11,15,19,20,21,17), (13,14,16,22,23,24,18), (15,16,22,19), 
      (17,18,24,21), (19,20,23,22), (20,21,24,23) ] ]
</pre></div>

<p><a id="X7F1D30C67983EE96" name="X7F1D30C67983EE96"></a></p>

<h4>4.5 <span class="Heading">Constructing surfaces via their Dress Group</span></h4>

<p>In some constructions a surface may arrise from the knowledge of its Dress Group, see Section <a href="chap21.html#X7EAFC7CE7A9CA734"><span class="RefLink">21.2</span></a>. In this case, the surface can be reconstructed from its Dress group <span class="SimpleMath">D = ⟨ θ_0, θ_1, θ_2⟩</span> by computing the orbits of the dihedral subgroups <span class="SimpleMath">D_0 = ⟨ θ_1, θ_2⟩</span>, <span class="SimpleMath">D_1 = ⟨ θ_0, θ_2⟩</span>, <span class="SimpleMath">D_2 = ⟨ θ_0, θ_1⟩</span>, where <span class="Math">\theta_0, \theta_1, \theta_2</span> are the Dress Involutions, see <a href="chap21.html#X81065FFE7E779E4A"><span class="RefLink">21.2-1</span></a>. In particular, the vertices correspond to the orbits of <span class="SimpleMath">D_0</span>, the edges correspond to the orbits of <span class="SimpleMath">D_1</span>, the faces correspond to the orbits of <span class="SimpleMath">D_2</span>, and incidence is given by non-empty set-intersection.</p>

<p><a id="X7933327C787B3C7B" name="X7933327C787B3C7B"></a></p>

<h5>4.5-1 SimplicialSurfaceByDressGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplicialSurfaceByDressGroup</code>( <var class="Arg">dress</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a simplicial surface or false</p>

<p>This method takes as input a permutation group <var class="Arg">dress</var>, and tests, whether <var class="Arg">dress</var> is the Dress Group of a simplicial surface <var class="Arg">surf</var>, see Section <a href="chap21.html#X7EAFC7CE7A9CA734"><span class="RefLink">21.2</span></a>. If this is the case, <var class="Arg">surf</var> is constructed and returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tet := Tetrahedron();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dress := DressGroup(tet);</span>
Group([(1,7)(2,8)(3,13)(4,14)(5,19)(6,20)(9,15)(10,16)(11,21)(12,22)(17,23)(18,24), 
  (1,3)(2,5)(4,6)(7,9)(8,11)(10,12)(13,15)(14,18)(16,17)(19,21)(20,24)(22,23), 
  (1,2)(3,4)(5,6)(7,8)(9,10)(11,12)(13,14)(15,16)(17,18)(19,20)(21,22)(23,24) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">surf  := SimplicialSurfaceByDressGroup(dress);</span>
simplicial surface (4 vertices, 6 edges, and 4 faces)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> IsIsomorphic(surf, tet);</span>
true
</pre></div>

<p>If the permutation group <var class="Arg">dress</var> passed as an argument does not satisfy the conditions of being a dress group of a surface, <var class="Arg">false</var> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel(InfoSimplicial,3);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">grp:=Group([(1,2)(3,4)(5,6)(7,8),(1,2)(3,5)(4,7)(6,8),(1,3)(2,4)(5,7)(6,8)]);  </span>
Group([ (1,2)(3,4)(5,6)(7,8), (1,2)(3,5)(4,7)(6,8), (1,3)(2,4)(5,7)(6,8) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimplicialSurfaceByDressGroup(grp);</span>
#I  the dress relations are not satisfied.
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := [ ( 1, 6)( 2, 5)( 3, 4)( 7,12)( 8,11)( 9,10), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  ( 1, 8)( 2, 7)( 3,12)( 4, 5)( 6, 9)(10,11), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  ( 1,12)( 2,11)( 3,10)( 4, 9)( 5, 8)( 6, 7) ];</span>
[ (1,6)(2,5)(3,4)(7,12)(8,11)(9,10), (1,8)(2,7)(3,12)(4,5)(6,9)(10,11), 
 (1,12)(2,11)(3,10)(4,9)(5,8)(6,7) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SimplicialSurfaceByDressGroup(Group(gens));</span>
#I  Faces and vertices can have only 2 common flags
false
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
