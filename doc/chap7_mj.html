<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (SimplicialSurfaces) - Chapter 7: Homomorphisms</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap7"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap7.html">[MathJax off]</a></p>
<p><a id="X84975388859F203D" name="X84975388859F203D"></a></p>
<div class="ChapSects"><a href="chap7_mj.html#X84975388859F203D">7 <span class="Heading">Homomorphisms</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X7937FC407C405232">7.1 <span class="Heading">Construction of Morphisms</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7C7EAC6278E1C63A">7.1-1 PolygonalMorphismByLists</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7C3E22F881BDFA51">7.1-2 PolygonalMorphismByVertexImages</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X8203EEC4862BD7D9">7.1-3 PolygonalIdentityMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X86C65DCA86A65C7E">7.1-4 CompositionMapping</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X80E3F2697D110BDA">7.1-5 InversePolygonalMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7AF61B01864730D8">7.1-6 ButterflyFaithfulMonomorphismIntoSimplicialSurface</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X845ECD107B32BCA2">7.1-7 AllButterflyFaithfulMonomorphismsIntoSimplicialSurface</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X7AFAB3B781CCB7AC">7.2 <span class="Heading">Images and pre-images</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X816FDA1278BC8E9B">7.2-1 ImageOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7BF9367985229530">7.2-2 ImageOfEdge</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7C04887579FDAB1D">7.2-3 ImageOfFace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7AEBE53A7E9EEB9B">7.2-4 PreImagesOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X83C0B2607F9376BB">7.2-5 PreImagesOfEdge</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X843D0C6C78A2A854">7.2-6 PreImagesOfFace</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X7BBEAB7D8550B0D4">7.3 <span class="Heading">Consistent labels for vertices, edges, and faces</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7F340CA578AF70BD">7.3-1 VEFLabels</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X848C7D0E87DC3000">7.3-2 VEFLabelsOfVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X82122B28792294DA">7.3-3 VEFLabelsOfEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X806A55377E134A35">7.3-4 VEFLabelsOfFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X780C1A66782EE7BF">7.3-5 VertexOfVEFLabel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X782B1E0078485ED9">7.3-6 EdgeOfVEFLabel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X7EA162E8867F2E0B">7.3-7 FaceOfVEFLabel</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7_mj.html#X7B89BCFF80E23C51">7.4 <span class="Heading">Components of a morphism</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X87C2DDF77E55BAB3">7.4-1 SourceComplex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X8055458B859E3487">7.4-2 RangeComplex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X838ADE8982DB6E4C">7.4-3 VertexMapAsImageList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X78880CC786815722">7.4-4 EdgeMapAsImageList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X79E91DA778B627F0">7.4-5 FaceMapAsImageList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7_mj.html#X79AD396A7A661488">7.4-6 VEFLabelMapAsImageList</a></span>
</div></div>
</div>

<h3>7 <span class="Heading">Homomorphisms</span></h3>

<p>This chapter is concerned with morphisms between different polygonal complexes (morphisms between twisted polygonal complexes are not implemented so far).</p>

<p>A morphism between two polygonal complexes <span class="SimpleMath">\((V_1,E_1,F_1)\)</span> and <span class="SimpleMath">\((V_2,E_2,F_2)\)</span> consists of maps <span class="SimpleMath">\(V_1 \to V_2\)</span>, <span class="SimpleMath">\(E_1 \to E_2\)</span>, and <span class="SimpleMath">\(F_1 \to F_2\)</span>, such that</p>


<ul>
<li><p>incident elements remain incident</p>

</li>
<li><p>the two vertices of an edge are mapped to two different vertices</p>

</li>
<li><p>different vertices/edges of a face are mapped to different vertices/edges (for example, a face with six edges cannot be mapped to a face with three edges)</p>

</li>
</ul>
<p>Since polygonal morphisms are stored as mappings (in the GAP-sense), all methods available for mappings (in particular those from section <a href="/opt/gap/doc/ref/chap32_mj.html#X7E5A430D7F838F1C"><span class="RefLink">Reference: Properties and Attributes of (General) Mappings</span></a>) are available for polygonal morphisms. In particular, <code class="keyw">IsInjective</code>, <code class="keyw">IsSurjective</code>, <code class="keyw">IsBijective</code>.</p>

<p>If the edges and faces of the polygonal complexes are uniquely defined by their vertices (which can be tested by <code class="keyw">IsAnomalyFree</code>, compare <a href="chap16_mj.html#X85509F8A82079CA8"><span class="RefLink">16.1-1</span></a>), the polygonal morphism can be defined by the vertex map (the more flexible constructor in <a href="chap7_mj.html#X7C7EAC6278E1C63A"><span class="RefLink">7.1-1</span></a> requires all three maps). Consider the following example, in which the face 2 is mapped to the face 2, and both the faces 3 and 4 are mapped to the face 3:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">source := PolygonalSurfaceByDownwardIncidence( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,2],[2,3],[3,4],,[1,6],,[2,7],[3,7],[4,7],,,[6,7]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [,[1,7,12,5],[2,7,8],[3,8,9]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">range := PolygonalSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,2],[2,3],,[1,5],[2,5],,[3,6],[3,7],,,[5,6],[6,7]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,4,5],[2,5,11,7],[7,8,12]]);;</span>
</pre></div>

<p><br><img src="./images/_Wrapper_Image_PolygonalMorphism_Strip-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">polMor := PolygonalMorphismByVertexImages(source,range, [5,6,7,6,,2,3]);</span>
&lt;polygonal morphism&gt;
</pre></div>

<p>The most important aspect of a morphism is determining images and preimages of vertices, edges, and faces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfEdge(polMor, 12);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfFace(polMor, 4);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfEdge(polMor, 12);</span>
[ 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfFace(polMor, 1);</span>
[  ]
</pre></div>

<p><a id="X7937FC407C405232" name="X7937FC407C405232"></a></p>

<h4>7.1 <span class="Heading">Construction of Morphisms</span></h4>

<p>In this section, we give several different ways to construct morphisms from scratch.</p>

<p><a id="X7C7EAC6278E1C63A" name="X7C7EAC6278E1C63A"></a></p>

<h5>7.1-1 PolygonalMorphismByLists</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalMorphismByLists</code>( <var class="Arg">sourceComplex</var>, <var class="Arg">rangeComplex</var>, <var class="Arg">vertexMap</var>, <var class="Arg">edgeMap</var>, <var class="Arg">faceMap</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalMorphismByListsNC</code>( <var class="Arg">sourceComplex</var>, <var class="Arg">rangeComplex</var>, <var class="Arg">vertexMap</var>, <var class="Arg">edgeMap</var>, <var class="Arg">faceMap</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal mapping</p>

<p>Construct a polygonal morphism by three lists. The necessary arguments are</p>


<ul>
<li><p><var class="Arg">sourceComplex</var>: The polygonal complex that become the source of the polygonal morphism.</p>

</li>
<li><p><var class="Arg">rangeComplex</var>: The polygonal complex that becomes the range of the polygonal morphism.</p>

</li>
<li><p><var class="Arg">vertexMap</var>: A list, such that for each vertex <var class="Arg">v</var> in <var class="Arg">sourceComplex</var>, the element <var class="Arg">vertexMap[v]</var> is a vertex in <var class="Arg">rangeComplex</var>, representing the image under the polygonal morphism.</p>

</li>
<li><p><var class="Arg">edgeMap</var>: A list, such that for each edge <var class="Arg">e</var> in <var class="Arg">sourceComplex</var>, the element <var class="Arg">edgeMap[v]</var> is an edge in <var class="Arg">rangeComplex</var>, representing the image under the polygonal morphism.</p>

</li>
<li><p><var class="Arg">faceMap</var>: A list, such that for each face <var class="Arg">f</var> in <var class="Arg">sourceComplex</var>, the element <var class="Arg">faceMap[v]</var> is a face in <var class="Arg">rangeComplex</var>, representing the image under the polygonal morphism.</p>

</li>
</ul>
<p>As an illustration we define a polygonal morphisms from a 6-umbrella to a 3--umbrella. <br><img src='./images/_Wrapper_morphisms-1-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">six := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,4],[4,5],[5,6],[6,1],,[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,8,9],[2,9,10],[3,10,11],[4,11,12],[5,12,13],[6,13,8]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">three := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,1],,[1,5],[2,5],[3,5]], [[1,5,6],[2,6,7],[3,7,5]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vertexMap := [1,2,3,1,2,3,,5];</span>
[ 1, 2, 3, 1, 2, 3,, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edgeMap := [1,2,3,1,2,3,,5,6,7,5,6,7];</span>
[ 1, 2, 3, 1, 2, 3,, 5, 6, 7, 5, 6, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">faceMap := [1,2,3,1,2,3];</span>
[ 1, 2, 3, 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">polMor := PolygonalMorphismByLists(six, three, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       vertexMap, edgeMap, faceMap);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SourceComplex(polMor) = six;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RangeComplex(polMor) = three;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexMapAsImageList(polMor) = vertexMap;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeMapAsImageList(polMor) = edgeMap;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceMapAsImageList(polMor) = faceMap;</span>
true
</pre></div>

<p>The NC-version does not check whether:</p>


<ul>
<li><p>The individual argument lists map every vertex/edge/face of <var class="Arg">sourceComplex</var> to a vertex/edge/face of <var class="Arg">rangeComplex</var>.</p>

</li>
<li><p>The incidence structure is preserved by the mapping.</p>

</li>
<li><p>The vertices incident to an edge are mappped to different vertices.</p>

</li>
<li><p>A polygon is mapped to a polygon with the same number of sides.</p>

</li>
<li><p>The edges incident to a face are mapped to different edges.</p>

</li>
<li><p>The vertices incident to a face are mapped to different vertices.</p>

</li>
</ul>
<p><a id="X7C3E22F881BDFA51" name="X7C3E22F881BDFA51"></a></p>

<h5>7.1-2 PolygonalMorphismByVertexImages</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalMorphismByVertexImages</code>( <var class="Arg">sourceComplex</var>, <var class="Arg">rangeComplex</var>, <var class="Arg">vertexMap</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalMorphismByVertexImagesNC</code>( <var class="Arg">sourceComplex</var>, <var class="Arg">rangeComplex</var>, <var class="Arg">vertexMap</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal mapping</p>

<p>Given two vertex-faithful (<a href="chap16_mj.html#X85509F8A82079CA8"><span class="RefLink">16.1-1</span></a>) polygonal complexes and a map between their vertices, construct a polygonal morphism extending the vertex map. The arguments are:</p>


<ul>
<li><p><var class="Arg">sourceComplex</var>: The vertex-faithful polygonal complex that become the source of the polygonal morphism.</p>

</li>
<li><p><var class="Arg">rangeComplex</var>: The vertex-faithful polygonal complex that becomes the range of the polygonal morphism.</p>

</li>
<li><p><var class="Arg">vertexMap</var>: A list, such that for each vertex <var class="Arg">v</var> in <var class="Arg">sourceComplex</var>, the element <var class="Arg">vertexMap[v]</var> is a vertex in <var class="Arg">rangeComplex</var>, representing the image under the polygonal morphism.</p>

</li>
</ul>
<p>As an illustration we define a polygonal morphisms from a 6-umbrella to a 3--umbrella. <br><img src='./images/_Wrapper_morphisms-2-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">six := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,4],[4,5],[5,6],[6,1],,[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,8,9],[2,9,10],[3,10,11],[4,11,12],[5,12,13],[6,13,8]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">three := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,1],,[1,5],[2,5],[3,5]], [[1,5,6],[2,6,7],[3,7,5]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vertexMap := [1,2,3,1,2,3,,5];</span>
[ 1, 2, 3, 1, 2, 3,, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">polMor := PolygonalMorphismByVertexImages(six, three, vertexMap);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SourceComplex(polMor) = six;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RangeComplex(polMor) = three;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexMapAsImageList(polMor) = vertexMap;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeMapAsImageList(polMor);</span>
[ 1, 2, 3, 1, 2, 3,, 5, 6, 7, 5, 6, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceMapAsImageList(polMor);</span>
[ 1, 2, 3, 1, 2, 3 ]
</pre></div>

<p>The NC-version does not check whether:</p>


<ul>
<li><p>The list <var class="Arg">vertexMap</var> maps every vertex of <var class="Arg">sourceComplex</var> to a vertex of <var class="Arg">rangeComplex</var>.</p>

</li>
<li><p>The incidence structure is preserved by the mapping.</p>

</li>
<li><p>The vertices incident to an edge are mappped to different vertices.</p>

</li>
<li><p>A polygon is mapped to a polygon with the same number of sides.</p>

</li>
<li><p>The vertices incident to a face are mapped to different vertices.</p>

</li>
</ul>
<p><a id="X8203EEC4862BD7D9" name="X8203EEC4862BD7D9"></a></p>

<h5>7.1-3 PolygonalIdentityMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolygonalIdentityMorphism</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal mapping</p>

<p>Given a polygonal complex, return the polygonal morphism that sends this complex to itself (the identity morphism).</p>

<p>As an example, consider the tetrahedron: <br><img src='./images/_Wrapper_morphisms-3-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tetra := Tetrahedron();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := PolygonalIdentityMorphism(tetra);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SourceComplex(id) = tetra;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RangeComplex(id) = tetra;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexMapAsImageList(id);</span>
[ 1, 2, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeMapAsImageList(id);</span>
[ 1, 2, 3, 4, 5, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceMapAsImageList(id);</span>
[ 1, 2, 3, 4 ]
</pre></div>

<p><a id="X86C65DCA86A65C7E" name="X86C65DCA86A65C7E"></a></p>

<h5>7.1-4 CompositionMapping</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompositionMapping</code>( <var class="Arg">mapLast</var>, <var class="Arg">mapSecondToLast</var>, <var class="Arg">...</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CompositionMapping2</code>( <var class="Arg">map2</var>, <var class="Arg">map1</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A polygonal morphism</p>

<p>Compose several polygonal morphisms. The method <code class="keyw">CompositionMapping2</code> returns the polygonal morphisms that is obtained by first applying <var class="Arg">map1</var> and then applying <var class="Arg">map2</var>.</p>

<p>The method <code class="keyw">CompositionMapping</code> can compose an arbitrary number of polygonal morphisms. Note that the first argument is the last map used in the composition. In addition, it also respects <code class="keyw">IsInjective</code> and <code class="keyw">IsSurjective</code>, if applicable.</p>

<p>If the range of the <span class="SimpleMath">\(i\)</span>-th map is not equal to the source of the <span class="SimpleMath">\((i+1)\)</span>th map, an error is raised.</p>

<p>We use a map from a six-umbrella to a three-umbrella as illustration. <br><img src='./images/_Wrapper_morphisms-1-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">six := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,4],[4,5],[5,6],[6,1],,[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,8,9],[2,9,10],[3,10,11],[4,11,12],[5,12,13],[6,13,8]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">three := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,1],,[1,5],[2,5],[3,5]], [[1,5,6],[2,6,7],[3,7,5]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor_6_to_6 := PolygonalIdentityMorphism(six);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor_3_to_3 := PolygonalMorphismByLists(three, three,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [2,3,1,,5], [2,3,1,,6,7,5], [2,3,1]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor_6_to_3 := PolygonalMorphismByLists(six, three, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [1,2,3,1,2,3,,5], [1,2,3,1,2,3,,5,6,7,5,6,7], [1,2,3,1,2,3]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comp := CompositionMapping2(mor_3_to_3, mor_6_to_3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexMapAsImageList(comp);</span>
[ 2, 3, 1, 2, 3, 1,, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeMapAsImageList(comp);</span>
[ 2, 3, 1, 2, 3, 1,, 6, 7, 5, 6, 7, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceMapAsImageList(comp);</span>
[ 2, 3, 1, 2, 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompositionMapping2(mor_6_to_3, mor_6_to_6) = mor_6_to_3;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompositionMapping(mor_3_to_3, mor_6_to_3, mor_6_to_6) = comp;</span>
true
</pre></div>

<p><a id="X80E3F2697D110BDA" name="X80E3F2697D110BDA"></a></p>

<h5>7.1-5 InversePolygonalMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InversePolygonalMorphism</code>( <var class="Arg">isoMor</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Inverse</code>( <var class="Arg">autoMor</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InverseGeneralMapping</code>( <var class="Arg">isoMor</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A polygonal morphism</p>

<p>Given a bijective polygonal morphism, one can define its inverse, i.e. a polygonal morphism, in which <code class="keyw">SourceComplex</code> (<a href="chap7_mj.html#X87C2DDF77E55BAB3"><span class="RefLink">7.4-1</span></a>) and <code class="keyw">RangeComplex</code> (<a href="chap7_mj.html#X8055458B859E3487"><span class="RefLink">7.4-2</span></a>) are switched.</p>

<p>Due to the way in which GAP handles inverses and mappings (compare the introduction of section <a href="/opt/gap/doc/ref/chap32_mj.html#X7E2E16277940FA0B"><span class="RefLink">Reference: Arithmetic Operations for General Mappings</span></a>), the different methods perform subtly different tasks:</p>


<ul>
<li><p><code class="keyw">InversePolygonalMorphism</code>(<var class="Arg">isoMor</var>) constructs the expected inverse map, from <code class="keyw">RangeComplex</code>(<var class="Arg">isoMor</var>) to <code class="keyw">SourceComplex</code>(<var class="Arg">isoMor</var>).</p>

</li>
<li><p><code class="keyw">Inverse</code>(<var class="Arg">autoMor</var>) <em>only</em> constructs this inverse, if <code class="keyw">SourceComplex</code>(<var class="Arg">autoMor</var>) and <code class="keyw">RangeComplex</code>(<var class="Arg">autoMor</var>) coincide.</p>

</li>
<li><p><code class="keyw">InverseGeneralMapping</code> does the same as <code class="keyw">InversePolygonalMorphism</code>, but might be subject to future change, if inverses are defined for non-bijective morphisms in the future.</p>

</li>
</ul>
<p>All of the methods throw errors if their requirements are not met.</p>

<p>To illustrate, we use a relabelling of a five-umbrella. <br><img src="./images/_Wrapper_Image_PolygonalMorphism_FiveUmbrella-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">left := SimplicialSurfaceByDownwardIncidence( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [[1,2],[1,3],[1,4],[1,5],[1,6],[2,3],[3,4],[4,5],[5,6],[6,2]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [[1,2,6],[2,3,7],[3,4,8],[4,5,9],[1,5,10]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">right := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [,[1,3],[1,4],[1,5],[1,6],[1,7],,[3,4],[4,5],[5,6],[6,7],[3,7]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [,,[2,3,8],[3,4,9],[4,5,10],[5,6,11],[2,6,12]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">morph := PolygonalMorphismByLists(left, right,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [1,3,4,5,6,7], [2,3,4,5,6,8,9,10,11,12], [3,4,5,6,7]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv := InversePolygonalMorphism(morph);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SourceComplex(inv) = right;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RangeComplex(inv) = left;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexMapAsImageList(inv);</span>
[ 1,, 2, 3, 4, 5, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeMapAsImageList(inv);</span>
[ , 1, 2, 3, 4, 5,, 6, 7, 8, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceMapAsImageList(inv);</span>
[,, 1, 2, 3, 4, 5 ]
</pre></div>

<p><a id="X7AF61B01864730D8" name="X7AF61B01864730D8"></a></p>

<h5>7.1-6 ButterflyFaithfulMonomorphismIntoSimplicialSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ButterflyFaithfulMonomorphismIntoSimplicialSurface</code>( <var class="Arg">surf1</var>, <var class="Arg">surf2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A polygonal morphism or <code class="keyw">fail</code></p>

<p>Given two simplicial surfaces <code class="keyw">surf1</code> and <code class="keyw">surf2</code>, return a butterfly-faithful monomorphism from <code class="keyw">surf1</code> to <code class="keyw">surf2</code> if it exists. Otherwise return <code class="keyw">fail</code>. A homomorphism of simplicial surfaces is called butterfly-faithful if the homomorphism when restricted to a butterfly, i.e. restricted to two incident faces of an inner edge, becomes a bijection onto another butterfly. In other words, every butterfly of <code class="keyw">surf1</code> is being preserved and does not degenerate in <code class="keyw">surf2</code>. As an example, consider the 3-half-umbrella and 6-umbrella. <br><img src="./images/_Wrapper_Butterfly_Faithful_Monomorphism_Hexagon.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">six := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,4],[4,5],[5,6],[6,1],,[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,8,9],[2,9,10],[3,10,11],[4,11,12],[5,12,13],[6,13,8]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">three := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,4],[5,4],[1,5],[2,5],[3,5]], [[1,5,6],[2,6,7],[3,7,4]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor_3_to_6 := ButterflyFaithfulMonomorphismIntoSimplicialSurface(three, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    six);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexMapAsImageList(mor_3_to_6);</span>
[ 1, 2, 3, 4, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeMapAsImageList(mor_3_to_6);</span>
[ 1, 2, 3, 11, 8, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceMapAsImageList(mor_3_to_6);</span>
[ 1, 2, 3 ]
</pre></div>

<p><a id="X845ECD107B32BCA2" name="X845ECD107B32BCA2"></a></p>

<h5>7.1-7 AllButterflyFaithfulMonomorphismsIntoSimplicialSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllButterflyFaithfulMonomorphismsIntoSimplicialSurface</code>( <var class="Arg">surf1</var>, <var class="Arg">surf2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of polygonal morphisms</p>

<p>Given two simplicial surfaces <code class="keyw">surf1</code> and <code class="keyw">surf2</code>, return a list of all butterfly-faithful monomorphisms from <code class="keyw">surf1</code> to <code class="keyw">surf2</code>. A homomorphism of simplicial surfaces is called butterfly-faithful if the homomorphism when restricted to a butterfly, i.e. restricted to two incident faces of an inner edge, becomes a bijection onto another butterfly. In other words, every butterfly of <code class="keyw">surf1</code> is being preserved and does not degenerate in <code class="keyw">surf2</code>. As an example, consider the 3-half-umbrella and 6-umbrella. We would expect 12 butterfly-faithful monomorphisms, namely by aligning the 3-half umbrella with 3 consecutive faces of the 6-umbrella. There are 6 ways to do this and another 6 if we flip the 3-half-umbrella first. <br><img src="./images/_Wrapper_Butterfly_Faithful_Monomorphism_Hexagon.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">six := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,4],[4,5],[5,6],[6,1],,[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,8,9],[2,9,10],[3,10,11],[4,11,12],[5,12,13],[6,13,8]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">three := SimplicialSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [[1,2],[2,3],[3,4],[5,4],[1,5],[2,5],[3,5]], [[1,5,6],[2,6,7],[3,7,4]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">all_mor_3_to_6 := AllButterflyFaithfulMonomorphismsIntoSimplicialSurface( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    three, six);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(all_mor_3_to_6);</span>
12
</pre></div>

<p><a id="X7AFAB3B781CCB7AC" name="X7AFAB3B781CCB7AC"></a></p>

<h4>7.2 <span class="Heading">Images and pre-images</span></h4>

<p>This section contains the functionality to compute images and preimages. Since polygonal morphisms connect two polygonal complexes, it is often necessary to make this connection explicit. For that reason, methods to compute images and preimages are provided.</p>

<p>Currently, the following methods are implemented:</p>


<ul>
<li><p>For vertices: <code class="keyw">ImageOfVertex</code> (<a href="chap7_mj.html#X816FDA1278BC8E9B"><span class="RefLink">7.2-1</span></a>) and <code class="keyw">PreImagesOfVertex</code> (<a href="chap7_mj.html#X7AEBE53A7E9EEB9B"><span class="RefLink">7.2-4</span></a>).</p>

</li>
<li><p>For edges: <code class="keyw">ImageOfEdge</code> (<a href="chap7_mj.html#X7BF9367985229530"><span class="RefLink">7.2-2</span></a>) and <code class="keyw">PreImagesOfEdge</code> (<a href="chap7_mj.html#X83C0B2607F9376BB"><span class="RefLink">7.2-5</span></a>).</p>

</li>
<li><p>For faces: <code class="keyw">ImageOfFace</code> (<a href="chap7_mj.html#X7C04887579FDAB1D"><span class="RefLink">7.2-3</span></a>) and <code class="keyw">PreImagesOfFace</code> (<a href="chap7_mj.html#X843D0C6C78A2A854"><span class="RefLink">7.2-6</span></a>).</p>

</li>
</ul>
<p>We illustrate these methods on the following polygonal morphism. <br><img src='./images/_Wrapper_morphisms-4-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">source := PolygonalComplexByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               [[1,2],, [2,4],, [4,5], [5,6],, [6,8],, [8,10],, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                [10,12],, [1,12], [2,12], [4,10], [4,6]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               [[1,14,15], [3,16,12,15],, [16,17,8,10], [5,6,17]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">range := PolygonalComplexByDownwardIncidence( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [[1,2], [2,3], [3,4], [4,5], [5,6],, [6,8],, [8,1], [2,8], [2,4], [4,6]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [[1,10,9], [2,3,11],, [11,12,7,10], [4,5,12]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">polMor := PolygonalMorphismByLists( source, range, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 1, 2,, 4, 3, 2,, 8,, 6,, 8 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 1,, 11,, 3, 2,, 10,, 7,, 7,, 9, 10, 12, 11 ], [ 1, 4,, 4, 2 ]);;</span>
</pre></div>

<p><a id="X816FDA1278BC8E9B" name="X816FDA1278BC8E9B"></a></p>

<h5>7.2-1 ImageOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageOfVertex</code>( <var class="Arg">polMor</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageOfVertexNC</code>( <var class="Arg">polMor</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a positive integer</p>

<p>Given a polygonal morphism <var class="Arg">polMor</var> and a vertex <var class="Arg">v</var>, return the image of <var class="Arg">v</var> under <var class="Arg">polMor</var>. If the given <var class="Arg">v</var> is not a vertex of the source complex (compare <a href="chap7_mj.html#X87C2DDF77E55BAB3"><span class="RefLink">7.4-1</span></a>) of <var class="Arg">polMor</var>, an error is raised. The NC-version does not check whether <var class="Arg">v</var> is a vertex of the source complex.</p>

<p>Consider the polygonal morphism from the start of section <a href="chap7_mj.html#X7AFAB3B781CCB7AC"><span class="RefLink">7.2</span></a> as illustration. <br><img src='./images/_Wrapper_morphisms-5-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfVertex(polMor, 1);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfVertex(polMor, 5);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfVertex(polMor, 6);</span>
2
</pre></div>

<p><a id="X7BF9367985229530" name="X7BF9367985229530"></a></p>

<h5>7.2-2 ImageOfEdge</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageOfEdge</code>( <var class="Arg">polMor</var>, <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageOfEdgeNC</code>( <var class="Arg">polMor</var>, <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a positive integer</p>

<p>Given a polygonal morphism <var class="Arg">polMor</var> and an edge <var class="Arg">e</var>, return the image of <var class="Arg">e</var> under <var class="Arg">polMor</var>. If the given <var class="Arg">e</var> is not an edge of the source complex (compare <a href="chap7_mj.html#X87C2DDF77E55BAB3"><span class="RefLink">7.4-1</span></a>) of <var class="Arg">polMor</var>, an error is raised. The NC-version does not check whether <var class="Arg">e</var> is an edge of the source complex.</p>

<p>Consider the polygonal morphism from the start of section <a href="chap7_mj.html#X7AFAB3B781CCB7AC"><span class="RefLink">7.2</span></a> as illustration. <br><img src='./images/_Wrapper_morphisms-6-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfEdge(polMor, 1);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfEdge(polMor, 5);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfEdge(polMor, 8);</span>
10
</pre></div>

<p><a id="X7C04887579FDAB1D" name="X7C04887579FDAB1D"></a></p>

<h5>7.2-3 ImageOfFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageOfFace</code>( <var class="Arg">polMor</var>, <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageOfFaceNC</code>( <var class="Arg">polMor</var>, <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a positive integer</p>

<p>Given a polygonal morphism <var class="Arg">polMor</var> and a face <var class="Arg">f</var>, return the image of <var class="Arg">f</var> under <var class="Arg">polMor</var>. If the given <var class="Arg">f</var> is not a face of the source complex (compare <a href="chap7_mj.html#X87C2DDF77E55BAB3"><span class="RefLink">7.4-1</span></a>) of <var class="Arg">polMor</var>, an error is raised. The NC-version does not check whether <var class="Arg">f</var> is a face of the source complex.</p>

<p>Consider the polygonal morphism from the start of section <a href="chap7_mj.html#X7AFAB3B781CCB7AC"><span class="RefLink">7.2</span></a> as illustration. <br><img src='./images/_Wrapper_morphisms-7-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfFace(polMor, 1);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfFace(polMor, 5);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageOfFace(polMor, 4);</span>
4
</pre></div>

<p><a id="X7AEBE53A7E9EEB9B" name="X7AEBE53A7E9EEB9B"></a></p>

<h5>7.2-4 PreImagesOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreImagesOfVertex</code>( <var class="Arg">polMor</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreImagesOfVertexNC</code>( <var class="Arg">polMor</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a set of positive integers</p>

<p>Given a polygonal morphism <var class="Arg">polMor</var> and a vertex <var class="Arg">v</var> of the range complex (compare <a href="chap7_mj.html#X8055458B859E3487"><span class="RefLink">7.4-2</span></a>), return the set of all preimages of <var class="Arg">v</var> under <var class="Arg">polMor</var>. If the given vertex <var class="Arg">v</var> is not a vertex of the range complexi, an error is raised.</p>

<p>The NC-version does not check whether <var class="Arg">v</var> is a vertex of the range complex.</p>

<p>Consider the polygonal morphism from the start of section <a href="chap7_mj.html#X7AFAB3B781CCB7AC"><span class="RefLink">7.2</span></a> as illustration. <br><img src='./images/_Wrapper_morphisms-8-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfVertex(polMor, 1);</span>
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfVertex(polMor, 2);</span>
[ 2, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfVertex(polMor, 5);</span>
[ ]
</pre></div>

<p><a id="X83C0B2607F9376BB" name="X83C0B2607F9376BB"></a></p>

<h5>7.2-5 PreImagesOfEdge</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreImagesOfEdge</code>( <var class="Arg">polMor</var>, <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreImagesOfEdgeNC</code>( <var class="Arg">polMor</var>, <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a set of positive integers</p>

<p>Given a polygonal morphism <var class="Arg">polMor</var> and an edge <var class="Arg">e</var> of the range complex (compare <a href="chap7_mj.html#X8055458B859E3487"><span class="RefLink">7.4-2</span></a>), return the set of all preimages of <var class="Arg">e</var> under <var class="Arg">polMor</var>. If the given edge <var class="Arg">e</var> is not an edge of the range complexi, an error is raised.</p>

<p>The NC-version does not check whether <var class="Arg">e</var> is an edge of the range complex.</p>

<p>Consider the polygonal morphism from the start of section <a href="chap7_mj.html#X7AFAB3B781CCB7AC"><span class="RefLink">7.2</span></a> as illustration. <br><img src='./images/_Wrapper_morphisms-9-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfEdge(polMor, 2);</span>
[ 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfEdge(polMor, 11);</span>
[ 3, 17 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfEdge(polMor, 4);</span>
[ ]
</pre></div>

<p><a id="X843D0C6C78A2A854" name="X843D0C6C78A2A854"></a></p>

<h5>7.2-6 PreImagesOfFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreImagesOfFace</code>( <var class="Arg">polMor</var>, <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreImagesOfFaceNC</code>( <var class="Arg">polMor</var>, <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a set of positive integers</p>

<p>Given a polygonal morphism <var class="Arg">polMor</var> and a face <var class="Arg">f</var> of the range complex (compare <a href="chap7_mj.html#X8055458B859E3487"><span class="RefLink">7.4-2</span></a>), return the set of all preimages of <var class="Arg">f</var> under <var class="Arg">polMor</var>. If the given face <var class="Arg">f</var> is not a face of the range complexi, an error is raised.</p>

<p>The NC-version does not check whether <var class="Arg">f</var> is a face of the range complex.</p>

<p>Consider the polygonal morphism from the start of section <a href="chap7_mj.html#X7AFAB3B781CCB7AC"><span class="RefLink">7.2</span></a> as illustration. <br><img src='./images/_Wrapper_morphisms-10-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfFace(polMor, 2);</span>
[ 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfFace(polMor, 4);</span>
[ 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreImagesOfFace(polMor, 5);</span>
[ ]
</pre></div>

<p><a id="X7BBEAB7D8550B0D4" name="X7BBEAB7D8550B0D4"></a></p>

<h4>7.3 <span class="Heading">Consistent labels for vertices, edges, and faces</span></h4>

<p>We have defined polygonal complexes in a way such that the labels for vertices, edges, and faces do not have to be distinct. While this is more convenient for the casual user, it is sometimes practical to enforce distinct labels. Notably, these cases include morphisms and automorphism groups.</p>

<p>The distinct label set is called <code class="keyw">VEFLabels</code>. Consider the following polygonal surface: <br><img src='./images/_Wrapper_morphisms-11-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := PolygonalSurfaceByUpwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1,2,4,5],, [1,7], [2,7,8], [8,9], [4,9,10], [5,10]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [[1], [1,2],, [2,4], [4],, [1], [2], [2], [4]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Vertices(cat);</span>
[ 1, 3, 4, 5, 6, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Edges(cat);</span>
[ 1, 2, 4, 5, 7, 8, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Faces(cat);</span>
[ 1, 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Intersection( Vertices(cat), Edges(cat) );</span>
[ 1, 4, 5, 7 ]
</pre></div>

<p>Using the VEF-labels shifts the labels of edges and faces upwards to avoid intersections. <br><img src='./images/_Wrapper_morphisms-12-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabels(cat);</span>
[ 1, 3, 4, 5, 6, 7, 8, 9, 11, 12, 14, 15, 16, 17, 18, 19, 21 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelsOfVertices(cat);</span>
[ 1,, 3, 4, 5, 6, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelsOfEdges(cat);</span>
[ 8, 9,, 11, 12,, 14, 15, 16, 17 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelsOfFaces(cat);</span>
[ 18, 19,, 21 ]
</pre></div>

<p><a id="X7F340CA578AF70BD" name="X7F340CA578AF70BD"></a></p>

<h5>7.3-1 VEFLabels</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabels</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a set of positive integers</p>

<p>Return the set of VEF-labels for the given polygonal complex. The VEF-labels are a set of labels that distinguish vertices, edges, and faces. It is constructed as follows:</p>


<ul>
<li><p>The vertex labels stay the same</p>

</li>
<li><p>The edge labels are shifted upwards by the maximal vertex label</p>

</li>
<li><p>The face labels are shifted upwards by the sum of maximal vertex label and maximal edge label</p>

</li>
</ul>
<p>For example, consider the polygonal surface from the start of section <a href="chap7_mj.html#X7BBEAB7D8550B0D4"><span class="RefLink">7.3</span></a>: <br><img src="./images/_Wrapper_Image_VEFLabels_SideBySide-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Vertices(cat);</span>
[ 1, 3, 4, 5, 6, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Edges(cat);</span>
[ 1, 2, 4, 5, 7, 8, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Faces(cat);</span>
[ 1, 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabels(cat);</span>
[ 1, 3, 4, 5, 6, 7, 8, 9, 11, 12, 14, 15, 16, 17, 18, 19, 21 ]
</pre></div>

<p><a id="X848C7D0E87DC3000" name="X848C7D0E87DC3000"></a></p>

<h5>7.3-2 VEFLabelsOfVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelsOfVertices</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelOfVertex</code>( <var class="Arg">complex</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelOfVertexNC</code>( <var class="Arg">complex</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list of positive integers / a positive integer</p>

<p>The method <code class="keyw">VEFLabelOfVertex</code>(<var class="Arg">complex</var>, <var class="Arg">vertex</var>) returns the VEF-label of <var class="Arg">vertex</var>. The NC-version does not check whether the given <var class="Arg">vertex</var> is a vertex of <var class="Arg">complex</var>.</p>

<p>The attribute <code class="keyw">VEFLabelsOfVertices</code>(<var class="Arg">complex</var>) collects all of those labels in a list that is indexed by the vertex labels, i.e. <code class="keyw">VEFLabelsOfOfVertices</code>(<var class="Arg">complex</var>)[<var class="Arg">vertex</var>] = <code class="keyw">VEFLabelOfVertex</code>(<var class="Arg">complex</var>, <var class="Arg">vertex</var>). All other positions of this list are not bound.</p>

<p>For example, consider the polygonal surface from the start of section <a href="chap7_mj.html#X7BBEAB7D8550B0D4"><span class="RefLink">7.3</span></a>: <br><img src="./images/_Wrapper_Image_VEFLabels_SideBySide-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelOfVertex(cat, 3);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelOfVertex(cat, 6);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelsOfVertices(cat);</span>
[ 1,, 3, 4, 5, 6, 7 ]
</pre></div>

<p><a id="X82122B28792294DA" name="X82122B28792294DA"></a></p>

<h5>7.3-3 VEFLabelsOfEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelsOfEdges</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelOfEdge</code>( <var class="Arg">complex</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelOfEdgeNC</code>( <var class="Arg">complex</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list of positive integers / a positive integer</p>

<p>The method <code class="keyw">VEFLabelOfEdge</code>(<var class="Arg">complex</var>, <var class="Arg">edge</var>) returns the VEF-label of <var class="Arg">edge</var>. The NC-version does not check whether the given <var class="Arg">edge</var> is an edge of <var class="Arg">complex</var>.</p>

<p>The attribute <code class="keyw">VEFLabelsOfEdges</code>(<var class="Arg">complex</var>) collects all of those labels in a list that is indexed by the edge labels, i.e. <code class="keyw">VEFLabelsOfOfEdges</code>(<var class="Arg">complex</var>)[<var class="Arg">edge</var>] = <code class="keyw">VEFLabelOfEdge</code>(<var class="Arg">complex</var>, <var class="Arg">edge</var>). All other positions of this list are not bound.</p>

<p>For example, consider the polygonal surface from the start of section <a href="chap7_mj.html#X7BBEAB7D8550B0D4"><span class="RefLink">7.3</span></a>: <br><img src="./images/_Wrapper_Image_VEFLabels_SideBySide-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelOfEdge(cat, 2);</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelOfEdge(cat, 10);</span>
17
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelsOfEdges(cat);</span>
[ 8, 9,, 11, 12,, 14, 15, 16, 17 ]
</pre></div>

<p><a id="X806A55377E134A35" name="X806A55377E134A35"></a></p>

<h5>7.3-4 VEFLabelsOfFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelsOfFaces</code>( <var class="Arg">complex</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelOfFace</code>( <var class="Arg">complex</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelOfFaceNC</code>( <var class="Arg">complex</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list of positive integers / a positive integer</p>

<p>The method <code class="keyw">VEFLabelOfFace</code>(<var class="Arg">complex</var>, <var class="Arg">face</var>) returns the VEF-label of <var class="Arg">face</var>. The NC-version does not check whether the given <var class="Arg">face</var> is a face of <var class="Arg">complex</var>.</p>

<p>The attribute <code class="keyw">VEFLabelsOfFaces</code>(<var class="Arg">complex</var>) collects all of those labels in a list that is indexed by the face labels, i.e. <code class="keyw">VEFLabelsOfOfFaces</code>(<var class="Arg">complex</var>)[<var class="Arg">face</var>] = <code class="keyw">VEFLabelOfFace</code>(<var class="Arg">complex</var>, <var class="Arg">face</var>). All other positions of this list are not bound.</p>

<p>For example, consider the polygonal surface from the start of section <a href="chap7_mj.html#X7BBEAB7D8550B0D4"><span class="RefLink">7.3</span></a>: <br><img src="./images/_Wrapper_Image_VEFLabels_SideBySide-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelOfFace(cat, 2);</span>
19
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelOfFace(cat, 4);</span>
21
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelsOfFaces(cat);</span>
[ 18, 19,, 21 ]
</pre></div>

<p><a id="X780C1A66782EE7BF" name="X780C1A66782EE7BF"></a></p>

<h5>7.3-5 VertexOfVEFLabel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VertexOfVEFLabel</code>( <var class="Arg">complex</var>, <var class="Arg">label</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VertexOfVEFLabelNC</code>( <var class="Arg">complex</var>, <var class="Arg">label</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a positive integer or <code class="keyw">fail</code></p>

<p>Given a polygonal complex <var class="Arg">complex</var> and a VEF-label <var class="Arg">label</var>, the method <code class="keyw">VertexOfVEFLabel</code>(<var class="Arg">complex</var>, <var class="Arg">label</var>) returns the vertex associated to <var class="Arg">label</var>.</p>

<p>For example, consider the polygonal surface from the start of section <a href="chap7_mj.html#X7BBEAB7D8550B0D4"><span class="RefLink">7.3</span></a>: <br><img src="./images/_Wrapper_Image_VEFLabels_SideBySide-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexOfVEFLabel(cat, 1);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexOfVEFLabel(cat, 2);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexOfVEFLabel(cat, 7);</span>
7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexOfVEFLabel(cat, 8);</span>
fail
</pre></div>

<p>The NC-version does not check whether the given <var class="Arg">label</var> is valid. The normal version checks this and returns <code class="keyw">fail</code> if <var class="Arg">label</var> is not valid.</p>

<p><a id="X782B1E0078485ED9" name="X782B1E0078485ED9"></a></p>

<h5>7.3-6 EdgeOfVEFLabel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EdgeOfVEFLabel</code>( <var class="Arg">complex</var>, <var class="Arg">label</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EdgeOfVEFLabelNC</code>( <var class="Arg">complex</var>, <var class="Arg">label</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a positive integer or <code class="keyw">fail</code></p>

<p>Given a polygonal complex <var class="Arg">complex</var> and a VEF-label <var class="Arg">label</var>, the method <code class="keyw">EdgeOfVEFLabel</code>(<var class="Arg">complex</var>, <var class="Arg">label</var>) returns the edge associated to <var class="Arg">label</var>.</p>

<p>For example, consider the polygonal surface from the start of section <a href="chap7_mj.html#X7BBEAB7D8550B0D4"><span class="RefLink">7.3</span></a>: <br><img src="./images/_Wrapper_Image_VEFLabels_SideBySide-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeOfVEFLabel(cat, 7);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeOfVEFLabel(cat, 9);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeOfVEFLabel(cat, 10);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeOfVEFLabel(cat, 16);</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeOfVEFLabel(cat, 18);</span>
fail
</pre></div>

<p>The NC-version does not check whether the given <var class="Arg">label</var> is valid. The normal version checks this and returns <code class="keyw">fail</code> if <var class="Arg">label</var> is not valid.</p>

<p><a id="X7EA162E8867F2E0B" name="X7EA162E8867F2E0B"></a></p>

<h5>7.3-7 FaceOfVEFLabel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FaceOfVEFLabel</code>( <var class="Arg">complex</var>, <var class="Arg">label</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FaceOfVEFLabelNC</code>( <var class="Arg">complex</var>, <var class="Arg">label</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a positive integer of <code class="keyw">fail</code></p>

<p>Given a polygonal complex <var class="Arg">complex</var> and a VEF-label <var class="Arg">label</var>, the method <code class="keyw">FaceOfVEFLabel</code>(<var class="Arg">complex</var>, <var class="Arg">label</var>) returns the face associated to <var class="Arg">label</var>.</p>

<p>For example, consider the polygonal surface from the start of section <a href="chap7_mj.html#X7BBEAB7D8550B0D4"><span class="RefLink">7.3</span></a>: <br><img src="./images/_Wrapper_Image_VEFLabels_SideBySide-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceOfVEFLabel(cat, 17);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceOfVEFLabel(cat, 18);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceOfVEFLabel(cat, 20);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceOfVEFLabel(cat, 21);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceOfVEFLabel(cat, 22);</span>
fail
</pre></div>

<p>The NC-version does not check whether the given <var class="Arg">label</var> is valid. The normal version checks this and returns <code class="keyw">fail</code> if <var class="Arg">label</var> is not valid.</p>

<p><a id="X7B89BCFF80E23C51" name="X7B89BCFF80E23C51"></a></p>

<h4>7.4 <span class="Heading">Components of a morphism</span></h4>

<p>This section contains the ingredients within a polygonal morphism, i.e. source and range complex, as well as the maps on vertices, edges, and faces.</p>

<p>We will illustrate them on the following polygonal morphism (on the sides are the VEF-labels): <br><img src="./images/_Wrapper_Image_PolygonalMorphism_Strip-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">source := PolygonalSurfaceByDownwardIncidence( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,2],[2,3],[3,4],,[1,6],,[2,7],[3,7],[4,7],,,[6,7]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [,[1,7,12,5],[2,7,8],[3,8,9]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">range := PolygonalSurfaceByDownwardIncidence(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,2],[2,3],,[1,5],[2,5],,[3,6],[3,7],,,[5,6],[6,7]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [[1,4,5],[2,5,11,7],[7,8,12]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">polMor := PolygonalMorphismByLists(source,range,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [5,6,7,6,,2,3], [11,12,12,,5,,7,8,7,,,2], [,2,3,3]);;</span>
</pre></div>

<p><a id="X87C2DDF77E55BAB3" name="X87C2DDF77E55BAB3"></a></p>

<h5>7.4-1 SourceComplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SourceComplex</code>( <var class="Arg">polMap</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SourceSurface</code>( <var class="Arg">polMap</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal complex</p>

<p>Return the polygonal complex (or surface) that is the source of the general polygonal mapping <var class="Arg">polMap</var>.</p>

<p>If the source is not a polygonal surface, then <code class="keyw">SourceSurface</code> will return <code class="keyw">fail</code>.</p>

<p><a id="X8055458B859E3487" name="X8055458B859E3487"></a></p>

<h5>7.4-2 RangeComplex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RangeComplex</code>( <var class="Arg">polMap</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RangeSurface</code>( <var class="Arg">polMap</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a polygonal complex</p>

<p>Return the polygonal complex (or surface) that is the range of the general polygonal mapping <var class="Arg">polMap</var>.</p>

<p>If the range is not a polygonal surface, then <code class="keyw">RangeSurface</code> will return <code class="keyw">fail</code>.</p>

<p><a id="X838ADE8982DB6E4C" name="X838ADE8982DB6E4C"></a></p>

<h5>7.4-3 VertexMapAsImageList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VertexMapAsImageList</code>( <var class="Arg">polMor</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Given a polygonal morphism <var class="Arg">polMor</var>, return the restriction of the mapping to the vertices. The result is a list <var class="Arg">vMap</var>, such that <var class="Arg">vMap[v]</var> is the image of the vertex <var class="Arg">v</var> under the polygonal morphism <var class="Arg">polMor</var>. All other list entries are not bound.</p>

<p>We illustrate this on the polygonal morphism from the start of section <a href="chap7_mj.html#X7B89BCFF80E23C51"><span class="RefLink">7.4</span></a>: <br><img src="./images/_Wrapper_Image_PolygonalMorphism_Strip-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VertexMapAsImageList(polMor);</span>
[ 5, 6, 7, 6,, 2, 3 ]
</pre></div>

<p><a id="X78880CC786815722" name="X78880CC786815722"></a></p>

<h5>7.4-4 EdgeMapAsImageList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EdgeMapAsImageList</code>( <var class="Arg">polMor</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Given a polygonal morphism <var class="Arg">polMor</var>, return the restriction of the mapping to the edges. The result is a list <var class="Arg">eMap</var>, such that <var class="Arg">eMap[e]</var> is the image of the edge <var class="Arg">e</var> under the polygonal morphism <var class="Arg">polMor</var>. All other list entries are not bound.</p>

<p>We illustrate this on the polygonal morphism from the start of section <a href="chap7_mj.html#X7B89BCFF80E23C51"><span class="RefLink">7.4</span></a>: <br><img src="./images/_Wrapper_Image_PolygonalMorphism_Strip-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EdgeMapAsImageList(polMor);</span>
[ 11, 12, 12,, 5,, 7, 8, 7,,, 2 ]
</pre></div>

<p><a id="X79E91DA778B627F0" name="X79E91DA778B627F0"></a></p>

<h5>7.4-5 FaceMapAsImageList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FaceMapAsImageList</code>( <var class="Arg">polMor</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Given a polygonal morphism <var class="Arg">polMor</var>, return the restriction of the mapping to the faces. The result is a list <var class="Arg">fMap</var>, such that <var class="Arg">fMap[f]</var> is the image of the face <var class="Arg">f</var> under the polygonal morphism <var class="Arg">polMor</var>. All other list entries are not bound.</p>

<p>We illustrate this on the polygonal morphism from the start of section <a href="chap7_mj.html#X7B89BCFF80E23C51"><span class="RefLink">7.4</span></a>: <br><img src="./images/_Wrapper_Image_PolygonalMorphism_Strip-1.svg"> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceMapAsImageList(polMor);</span>
[ , 2, 3, 3 ]
</pre></div>

<p><a id="X79AD396A7A661488" name="X79AD396A7A661488"></a></p>

<h5>7.4-6 VEFLabelMapAsImageList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VEFLabelMapAsImageList</code>( <var class="Arg">polMor</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>A polygonal morphism <var class="Arg">polMor</var> can be described by a map between the VEF-labels of source and target complex. This method returns this map as an image list, i.e. it returns a list <var class="Arg">vefMap</var>, such that <var class="Arg">vefMap[x]</var> is the image of the VEF-label <var class="Arg">x</var>. All other list entries are not bound.</p>

<p>We illustrate this on the polygonal morphism from the start of section <a href="chap7_mj.html#X7B89BCFF80E23C51"><span class="RefLink">7.4</span></a> (the VEF-labels are drawn on the sides). <br><img src='./images/_Wrapper_morphisms-13-1.svg'> </img> <br></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VEFLabelMapAsImageList(polMor);</span>
[ 5, 6, 7, 6,, 2, 3, 18, 19, 19,, 12,, 14, 15, 14,,, 9,, 21, 22, 22 ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chap20_mj.html">20</a>  <a href="chap21_mj.html">21</a>  <a href="chap22_mj.html">22</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
